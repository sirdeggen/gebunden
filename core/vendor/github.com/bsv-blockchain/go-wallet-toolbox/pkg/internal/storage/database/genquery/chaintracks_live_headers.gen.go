// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package genquery

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/bsv-blockchain/go-wallet-toolbox/pkg/internal/storage/database/models"
)

func newChaintracksLiveHeader(db *gorm.DB, opts ...gen.DOOption) chaintracksLiveHeader {
	_chaintracksLiveHeader := chaintracksLiveHeader{}

	_chaintracksLiveHeader.chaintracksLiveHeaderDo.UseDB(db, opts...)
	_chaintracksLiveHeader.chaintracksLiveHeaderDo.UseModel(&models.ChaintracksLiveHeader{})

	tableName := _chaintracksLiveHeader.chaintracksLiveHeaderDo.TableName()
	_chaintracksLiveHeader.ALL = field.NewAsterisk(tableName)
	_chaintracksLiveHeader.HeaderID = field.NewUint(tableName, "headerId")
	_chaintracksLiveHeader.PreviousHeaderID = field.NewUint(tableName, "previousHeaderId")
	_chaintracksLiveHeader.PreviousHash = field.NewString(tableName, "previousHash")
	_chaintracksLiveHeader.Height = field.NewUint(tableName, "height")
	_chaintracksLiveHeader.IsActive = field.NewBool(tableName, "isActive")
	_chaintracksLiveHeader.IsChainTip = field.NewBool(tableName, "isChainTip")
	_chaintracksLiveHeader.Hash = field.NewString(tableName, "hash")
	_chaintracksLiveHeader.ChainWork = field.NewString(tableName, "chainWork")
	_chaintracksLiveHeader.Version = field.NewUint32(tableName, "version")
	_chaintracksLiveHeader.MerkleRoot = field.NewString(tableName, "merkleRoot")
	_chaintracksLiveHeader.Time = field.NewUint32(tableName, "time")
	_chaintracksLiveHeader.Bits = field.NewUint32(tableName, "bits")
	_chaintracksLiveHeader.Nonce = field.NewUint32(tableName, "nonce")
	_chaintracksLiveHeader.PreviousHeader = chaintracksLiveHeaderBelongsToPreviousHeader{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("PreviousHeader", "models.ChaintracksLiveHeader"),
		PreviousHeader: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("PreviousHeader.PreviousHeader", "models.ChaintracksLiveHeader"),
		},
	}

	_chaintracksLiveHeader.fillFieldMap()

	return _chaintracksLiveHeader
}

type chaintracksLiveHeader struct {
	chaintracksLiveHeaderDo

	ALL              field.Asterisk
	HeaderID         field.Uint
	PreviousHeaderID field.Uint
	PreviousHash     field.String
	Height           field.Uint
	IsActive         field.Bool
	IsChainTip       field.Bool
	Hash             field.String
	ChainWork        field.String
	Version          field.Uint32
	MerkleRoot       field.String
	Time             field.Uint32
	Bits             field.Uint32
	Nonce            field.Uint32
	PreviousHeader   chaintracksLiveHeaderBelongsToPreviousHeader

	fieldMap map[string]field.Expr
}

func (c chaintracksLiveHeader) Table(newTableName string) *chaintracksLiveHeader {
	c.chaintracksLiveHeaderDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c chaintracksLiveHeader) As(alias string) *chaintracksLiveHeader {
	c.chaintracksLiveHeaderDo.DO = *(c.chaintracksLiveHeaderDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *chaintracksLiveHeader) updateTableName(table string) *chaintracksLiveHeader {
	c.ALL = field.NewAsterisk(table)
	c.HeaderID = field.NewUint(table, "headerId")
	c.PreviousHeaderID = field.NewUint(table, "previousHeaderId")
	c.PreviousHash = field.NewString(table, "previousHash")
	c.Height = field.NewUint(table, "height")
	c.IsActive = field.NewBool(table, "isActive")
	c.IsChainTip = field.NewBool(table, "isChainTip")
	c.Hash = field.NewString(table, "hash")
	c.ChainWork = field.NewString(table, "chainWork")
	c.Version = field.NewUint32(table, "version")
	c.MerkleRoot = field.NewString(table, "merkleRoot")
	c.Time = field.NewUint32(table, "time")
	c.Bits = field.NewUint32(table, "bits")
	c.Nonce = field.NewUint32(table, "nonce")

	c.fillFieldMap()

	return c
}

func (c *chaintracksLiveHeader) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *chaintracksLiveHeader) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 14)
	c.fieldMap["headerId"] = c.HeaderID
	c.fieldMap["previousHeaderId"] = c.PreviousHeaderID
	c.fieldMap["previousHash"] = c.PreviousHash
	c.fieldMap["height"] = c.Height
	c.fieldMap["isActive"] = c.IsActive
	c.fieldMap["isChainTip"] = c.IsChainTip
	c.fieldMap["hash"] = c.Hash
	c.fieldMap["chainWork"] = c.ChainWork
	c.fieldMap["version"] = c.Version
	c.fieldMap["merkleRoot"] = c.MerkleRoot
	c.fieldMap["time"] = c.Time
	c.fieldMap["bits"] = c.Bits
	c.fieldMap["nonce"] = c.Nonce

}

func (c chaintracksLiveHeader) clone(db *gorm.DB) chaintracksLiveHeader {
	c.chaintracksLiveHeaderDo.ReplaceConnPool(db.Statement.ConnPool)
	c.PreviousHeader.db = db.Session(&gorm.Session{Initialized: true})
	c.PreviousHeader.db.Statement.ConnPool = db.Statement.ConnPool
	return c
}

func (c chaintracksLiveHeader) replaceDB(db *gorm.DB) chaintracksLiveHeader {
	c.chaintracksLiveHeaderDo.ReplaceDB(db)
	c.PreviousHeader.db = db.Session(&gorm.Session{})
	return c
}

type chaintracksLiveHeaderBelongsToPreviousHeader struct {
	db *gorm.DB

	field.RelationField

	PreviousHeader struct {
		field.RelationField
	}
}

func (a chaintracksLiveHeaderBelongsToPreviousHeader) Where(conds ...field.Expr) *chaintracksLiveHeaderBelongsToPreviousHeader {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a chaintracksLiveHeaderBelongsToPreviousHeader) WithContext(ctx context.Context) *chaintracksLiveHeaderBelongsToPreviousHeader {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a chaintracksLiveHeaderBelongsToPreviousHeader) Session(session *gorm.Session) *chaintracksLiveHeaderBelongsToPreviousHeader {
	a.db = a.db.Session(session)
	return &a
}

func (a chaintracksLiveHeaderBelongsToPreviousHeader) Model(m *models.ChaintracksLiveHeader) *chaintracksLiveHeaderBelongsToPreviousHeaderTx {
	return &chaintracksLiveHeaderBelongsToPreviousHeaderTx{a.db.Model(m).Association(a.Name())}
}

func (a chaintracksLiveHeaderBelongsToPreviousHeader) Unscoped() *chaintracksLiveHeaderBelongsToPreviousHeader {
	a.db = a.db.Unscoped()
	return &a
}

type chaintracksLiveHeaderBelongsToPreviousHeaderTx struct{ tx *gorm.Association }

func (a chaintracksLiveHeaderBelongsToPreviousHeaderTx) Find() (result *models.ChaintracksLiveHeader, err error) {
	return result, a.tx.Find(&result)
}

func (a chaintracksLiveHeaderBelongsToPreviousHeaderTx) Append(values ...*models.ChaintracksLiveHeader) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a chaintracksLiveHeaderBelongsToPreviousHeaderTx) Replace(values ...*models.ChaintracksLiveHeader) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a chaintracksLiveHeaderBelongsToPreviousHeaderTx) Delete(values ...*models.ChaintracksLiveHeader) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a chaintracksLiveHeaderBelongsToPreviousHeaderTx) Clear() error {
	return a.tx.Clear()
}

func (a chaintracksLiveHeaderBelongsToPreviousHeaderTx) Count() int64 {
	return a.tx.Count()
}

func (a chaintracksLiveHeaderBelongsToPreviousHeaderTx) Unscoped() *chaintracksLiveHeaderBelongsToPreviousHeaderTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type chaintracksLiveHeaderDo struct{ gen.DO }

type IChaintracksLiveHeaderDo interface {
	gen.SubQuery
	Debug() IChaintracksLiveHeaderDo
	WithContext(ctx context.Context) IChaintracksLiveHeaderDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IChaintracksLiveHeaderDo
	WriteDB() IChaintracksLiveHeaderDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IChaintracksLiveHeaderDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IChaintracksLiveHeaderDo
	Not(conds ...gen.Condition) IChaintracksLiveHeaderDo
	Or(conds ...gen.Condition) IChaintracksLiveHeaderDo
	Select(conds ...field.Expr) IChaintracksLiveHeaderDo
	Where(conds ...gen.Condition) IChaintracksLiveHeaderDo
	Order(conds ...field.Expr) IChaintracksLiveHeaderDo
	Distinct(cols ...field.Expr) IChaintracksLiveHeaderDo
	Omit(cols ...field.Expr) IChaintracksLiveHeaderDo
	Join(table schema.Tabler, on ...field.Expr) IChaintracksLiveHeaderDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IChaintracksLiveHeaderDo
	RightJoin(table schema.Tabler, on ...field.Expr) IChaintracksLiveHeaderDo
	Group(cols ...field.Expr) IChaintracksLiveHeaderDo
	Having(conds ...gen.Condition) IChaintracksLiveHeaderDo
	Limit(limit int) IChaintracksLiveHeaderDo
	Offset(offset int) IChaintracksLiveHeaderDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IChaintracksLiveHeaderDo
	Unscoped() IChaintracksLiveHeaderDo
	Create(values ...*models.ChaintracksLiveHeader) error
	CreateInBatches(values []*models.ChaintracksLiveHeader, batchSize int) error
	Save(values ...*models.ChaintracksLiveHeader) error
	First() (*models.ChaintracksLiveHeader, error)
	Take() (*models.ChaintracksLiveHeader, error)
	Last() (*models.ChaintracksLiveHeader, error)
	Find() ([]*models.ChaintracksLiveHeader, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.ChaintracksLiveHeader, err error)
	FindInBatches(result *[]*models.ChaintracksLiveHeader, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.ChaintracksLiveHeader) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IChaintracksLiveHeaderDo
	Assign(attrs ...field.AssignExpr) IChaintracksLiveHeaderDo
	Joins(fields ...field.RelationField) IChaintracksLiveHeaderDo
	Preload(fields ...field.RelationField) IChaintracksLiveHeaderDo
	FirstOrInit() (*models.ChaintracksLiveHeader, error)
	FirstOrCreate() (*models.ChaintracksLiveHeader, error)
	FindByPage(offset int, limit int) (result []*models.ChaintracksLiveHeader, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IChaintracksLiveHeaderDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c chaintracksLiveHeaderDo) Debug() IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Debug())
}

func (c chaintracksLiveHeaderDo) WithContext(ctx context.Context) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c chaintracksLiveHeaderDo) ReadDB() IChaintracksLiveHeaderDo {
	return c.Clauses(dbresolver.Read)
}

func (c chaintracksLiveHeaderDo) WriteDB() IChaintracksLiveHeaderDo {
	return c.Clauses(dbresolver.Write)
}

func (c chaintracksLiveHeaderDo) Session(config *gorm.Session) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Session(config))
}

func (c chaintracksLiveHeaderDo) Clauses(conds ...clause.Expression) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c chaintracksLiveHeaderDo) Returning(value interface{}, columns ...string) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c chaintracksLiveHeaderDo) Not(conds ...gen.Condition) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c chaintracksLiveHeaderDo) Or(conds ...gen.Condition) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c chaintracksLiveHeaderDo) Select(conds ...field.Expr) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c chaintracksLiveHeaderDo) Where(conds ...gen.Condition) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c chaintracksLiveHeaderDo) Order(conds ...field.Expr) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c chaintracksLiveHeaderDo) Distinct(cols ...field.Expr) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c chaintracksLiveHeaderDo) Omit(cols ...field.Expr) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c chaintracksLiveHeaderDo) Join(table schema.Tabler, on ...field.Expr) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c chaintracksLiveHeaderDo) LeftJoin(table schema.Tabler, on ...field.Expr) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c chaintracksLiveHeaderDo) RightJoin(table schema.Tabler, on ...field.Expr) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c chaintracksLiveHeaderDo) Group(cols ...field.Expr) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c chaintracksLiveHeaderDo) Having(conds ...gen.Condition) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c chaintracksLiveHeaderDo) Limit(limit int) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c chaintracksLiveHeaderDo) Offset(offset int) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c chaintracksLiveHeaderDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c chaintracksLiveHeaderDo) Unscoped() IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Unscoped())
}

func (c chaintracksLiveHeaderDo) Create(values ...*models.ChaintracksLiveHeader) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c chaintracksLiveHeaderDo) CreateInBatches(values []*models.ChaintracksLiveHeader, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c chaintracksLiveHeaderDo) Save(values ...*models.ChaintracksLiveHeader) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c chaintracksLiveHeaderDo) First() (*models.ChaintracksLiveHeader, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.ChaintracksLiveHeader), nil
	}
}

func (c chaintracksLiveHeaderDo) Take() (*models.ChaintracksLiveHeader, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.ChaintracksLiveHeader), nil
	}
}

func (c chaintracksLiveHeaderDo) Last() (*models.ChaintracksLiveHeader, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.ChaintracksLiveHeader), nil
	}
}

func (c chaintracksLiveHeaderDo) Find() ([]*models.ChaintracksLiveHeader, error) {
	result, err := c.DO.Find()
	return result.([]*models.ChaintracksLiveHeader), err
}

func (c chaintracksLiveHeaderDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.ChaintracksLiveHeader, err error) {
	buf := make([]*models.ChaintracksLiveHeader, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c chaintracksLiveHeaderDo) FindInBatches(result *[]*models.ChaintracksLiveHeader, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c chaintracksLiveHeaderDo) Attrs(attrs ...field.AssignExpr) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c chaintracksLiveHeaderDo) Assign(attrs ...field.AssignExpr) IChaintracksLiveHeaderDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c chaintracksLiveHeaderDo) Joins(fields ...field.RelationField) IChaintracksLiveHeaderDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c chaintracksLiveHeaderDo) Preload(fields ...field.RelationField) IChaintracksLiveHeaderDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c chaintracksLiveHeaderDo) FirstOrInit() (*models.ChaintracksLiveHeader, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.ChaintracksLiveHeader), nil
	}
}

func (c chaintracksLiveHeaderDo) FirstOrCreate() (*models.ChaintracksLiveHeader, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.ChaintracksLiveHeader), nil
	}
}

func (c chaintracksLiveHeaderDo) FindByPage(offset int, limit int) (result []*models.ChaintracksLiveHeader, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c chaintracksLiveHeaderDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c chaintracksLiveHeaderDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c chaintracksLiveHeaderDo) Delete(models ...*models.ChaintracksLiveHeader) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *chaintracksLiveHeaderDo) withDO(do gen.Dao) *chaintracksLiveHeaderDo {
	c.DO = *do.(*gen.DO)
	return c
}
