package settings

import (
	"net/url"
	"time"
)

// LegacySettings configures the legacy Bitcoin wire protocol service.
type LegacySettings struct {
	WorkingDir                       string        `key:"legacy_workingDir" desc:"Working directory for legacy operations" default:"../../data" category:"Legacy" usage:"Path for legacy data storage" type:"string" longdesc:"### Purpose\nSpecifies the directory where the legacy Bitcoin protocol service stores its operational data.\n\n### How It Works\nThis directory contains:\n- **Peer database** - Known legacy node addresses\n- **Orphan transactions** - Transactions waiting for parent inputs\n- **Temporary files** - Protocol processing artifacts\n\n### Options\n- **Relative path** - Resolved relative to binary location\n- **Absolute path** - Full filesystem path\n\n### Recommendations\n- Use absolute paths in production for predictability\n- Ensure sufficient disk space for orphan transaction storage\n- Place on fast storage for better performance"`
	ListenAddresses                  []string      `key:"legacy_listen_addresses" desc:"Listen addresses for legacy Bitcoin protocol (pipe-separated)" default:"" category:"Legacy" usage:"For backward compatibility with older nodes" type:"[]string" longdesc:"### Purpose\nConfigures network addresses where the node accepts incoming connections from legacy Bitcoin protocol clients.\n\n### How It Works\nEnables backward compatibility with:\n- Bitcoin SV nodes not yet upgraded to Teranode\n- Legacy mining software\n- Traditional Bitcoin protocol tools\n\n### Options\n- **ip:port format** - Multiple addresses separated by pipes\n- **Empty string** - Disables legacy protocol listening entirely\n\n### Examples\n| Value | Description |\n|-------|-------------|\n| 0.0.0.0:8333 | Listen on all interfaces |\n| 192.168.1.10:8333 | Listen on specific IP |\n\n### Recommendations\n- Leave empty unless you need to connect with legacy nodes\n- Use firewall rules to restrict access in production"`
	ConnectPeers                     []string      `key:"legacy_connect_peers" desc:"Legacy peers to connect to (pipe-separated)" default:"" category:"Legacy" usage:"For syncing with legacy Bitcoin nodes" type:"[]string" longdesc:"### Purpose\nSpecifies legacy Bitcoin node addresses that this node should actively connect to as outbound peers.\n\n### How It Works\nThe node initiates connections to these addresses on startup and maintains persistent connections for:\n- Blockchain synchronization with legacy nodes\n- Transaction relay to legacy infrastructure\n- Block announcement propagation\n\n### Options\n- **ip:port format** - Multiple addresses separated by pipes\n- **Empty string** - No outbound legacy connections\n\n### Use Cases\n- Syncing with existing Bitcoin SV infrastructure\n- Connecting to known trusted legacy nodes\n- Private network setups with legacy components\n\n### Recommendations\n- Only connect to trusted legacy nodes\n- Monitor connection health in logs"`
	OrphanEvictionDuration           time.Duration `key:"legacy_orphanEvictionDuration" desc:"Duration before evicting orphan transactions" default:"10m" category:"Legacy" usage:"How long to keep orphan transactions" type:"duration" longdesc:"### Purpose\nControls how long orphan transactions are retained before being automatically removed from memory.\n\n### How It Works\nOrphan transactions are transactions received where one or more parent inputs are unknown. The node holds these temporarily hoping the parent transactions arrive soon.\n\nAfter this duration, orphans are evicted to:\n- Prevent memory exhaustion\n- Clean up transactions that will likely never complete\n- Protect against orphan flooding attacks\n\n### Trade-offs\n- **Longer duration** - More time for parent transactions to arrive, but uses more memory\n- **Shorter duration** - Less memory usage, but may prematurely evict valid orphans\n\n### Recommendations\n- Default of 10 minutes works well for most networks\n- Reduce on memory-constrained systems\n- Increase if experiencing frequent orphan re-requests"`
	StoreBatcherSize                 int           `key:"legacy_storeBatcherSize" desc:"Batch size for legacy store operations" default:"1024" category:"Legacy" usage:"Number of operations per batch" type:"int" longdesc:"### Purpose\nDefines the number of storage operations grouped together in a single batch when processing legacy protocol messages.\n\n### How It Works\nInstead of writing each item individually, operations are collected into batches:\n- Reduces storage round trips\n- Improves throughput for bulk data\n- Amortizes overhead across multiple operations\n\n### Trade-offs\n- **Larger batches** - Better throughput, higher memory usage, increased latency per item\n- **Smaller batches** - Lower latency, more storage overhead, reduced throughput\n\n### Recommendations\n- Default of 1024 balances throughput and memory well\n- Increase for high-volume legacy traffic\n- Decrease if memory is constrained"`
	StoreBatcherConcurrency          int           `key:"legacy_storeBatcherConcurrency" desc:"Concurrency for legacy store batcher" default:"32" category:"Legacy" usage:"Parallel store batch operations" type:"int" longdesc:"### Purpose\nControls the number of parallel workers processing storage batch operations for the legacy protocol.\n\n### How It Works\nMultiple workers can process independent batches simultaneously, enabling:\n- Parallel writes to storage backends\n- Better utilization of multi-core systems\n- Higher aggregate throughput\n\n### Trade-offs\n- **Higher concurrency** - Increased throughput, more resource usage, potential storage contention\n- **Lower concurrency** - Reduced resource usage, lower throughput\n\n### Recommendations\n- Default of 32 works well for most deployments\n- Scale with available CPU cores and storage backend capacity\n- Monitor storage backend for signs of contention"`
	SpendBatcherSize                 int           `key:"legacy_spendBatcherSize" desc:"Batch size for legacy spend operations" default:"1024" category:"Legacy" usage:"Number of spends per batch" type:"int" longdesc:"### Purpose\nDefines the number of UTXO spend operations grouped together in a single batch when processing legacy protocol transactions.\n\n### How It Works\nWhen transactions from the legacy protocol spend UTXOs, the operations are batched for efficiency:\n- Multiple spends processed together\n- Reduced UTXO store round trips\n- Improved validation throughput\n\n### Trade-offs\n- **Larger batches** - Better throughput for high-volume scenarios\n- **Smaller batches** - Lower latency for individual transactions\n\n### Recommendations\n- Keep aligned with **StoreBatcherSize** for consistent behavior\n- Default of 1024 is suitable for typical workloads"`
	SpendBatcherConcurrency          int           `key:"legacy_spendBatcherConcurrency" desc:"Concurrency for legacy spend batcher" default:"32" category:"Legacy" usage:"Parallel spend batch operations" type:"int" longdesc:"### Purpose\nControls the number of parallel workers processing UTXO spend batch operations for the legacy protocol.\n\n### How It Works\nMultiple workers process spend batches concurrently, enabling:\n- Parallel UTXO lookups and updates\n- Faster transaction validation\n- Better utilization of UTXO store capacity\n\n### Trade-offs\n- **Higher concurrency** - Faster processing, more UTXO store load\n- **Lower concurrency** - Less resource contention, slower throughput\n\n### Recommendations\n- Keep aligned with **StoreBatcherConcurrency** for consistent behavior\n- Default of 32 balances performance and resource usage"`
	OutpointBatcherSize              int           `key:"legacy_outpointBatcherSize" desc:"Batch size for legacy outpoint operations" default:"1024" category:"Legacy" usage:"Number of outpoints per batch" type:"int" longdesc:"### Purpose\nDefines the number of outpoint lookup operations grouped together in a single batch when processing legacy protocol requests.\n\n### How It Works\nOutpoints (transaction output references) are looked up in batches for efficiency:\n- Multiple outpoint queries combined\n- Reduced UTXO store round trips\n- Improved lookup throughput\n\n### Trade-offs\n- **Larger batches** - Better throughput for bulk lookups\n- **Smaller batches** - Lower latency for individual queries\n\n### Recommendations\n- Keep aligned with other batcher sizes for consistent behavior\n- Default of 1024 is suitable for typical workloads"`
	OutpointBatcherConcurrency       int           `key:"legacy_outpointBatcherConcurrency" desc:"Concurrency for legacy outpoint batcher" default:"32" category:"Legacy" usage:"Parallel outpoint batch operations" type:"int" longdesc:"### Purpose\nControls the number of parallel workers processing outpoint lookup batch operations for the legacy protocol.\n\n### How It Works\nMultiple workers process outpoint lookup batches concurrently, enabling:\n- Parallel UTXO queries\n- Faster transaction input resolution\n- Better utilization of UTXO store capacity\n\n### Trade-offs\n- **Higher concurrency** - Faster lookups, more UTXO store load\n- **Lower concurrency** - Less resource contention, slower throughput\n\n### Recommendations\n- Keep aligned with other batcher concurrency settings\n- Default of 32 balances performance and resource usage"`
	PrintInvMessages                 bool          `key:"legacy_printInvMessages" desc:"Print inventory messages for debugging" default:"false" category:"Legacy" usage:"Enable for legacy protocol debugging" type:"bool" longdesc:"### Purpose\nEnables verbose logging of inventory (inv) messages received through the legacy Bitcoin protocol.\n\n### How It Works\nWhen enabled, every inventory message is logged including:\n- Transaction announcements from peers\n- Block announcements\n- Other inventory vectors\n\n### Options\n- **true** - Log all inventory messages\n- **false** - Suppress inventory message logging\n\n### Trade-offs\n- **Enabled** - Useful for debugging protocol issues, generates high log volume\n- **Disabled** - Cleaner logs, less visibility into protocol traffic\n\n### Recommendations\n- **Disable in production** - Very verbose output\n- Enable temporarily when troubleshooting legacy peer connectivity\n- Use in conjunction with log rotation when enabled"`
	GRPCAddress                      string        `key:"legacy_grpcAddress" desc:"gRPC address for Legacy service" default:"" category:"Legacy" usage:"Address for legacy service communication" type:"string" longdesc:"### Purpose\nSpecifies the gRPC address used by other Teranode services to communicate with the legacy service.\n\n### How It Works\nOther microservices connect to this address to:\n- Request data from legacy peers\n- Coordinate transaction propagation\n- Exchange blockchain state information\n\n### Options\n- **host:port format** - Full address for the gRPC endpoint\n- **Empty string** - Legacy service gRPC client disabled\n\n### Recommendations\n- Configure when running distributed multi-service deployments\n- Use internal network addresses for security\n- Ensure firewall allows traffic between services"`
	AllowBlockPriority               bool          `key:"legacy_allowBlockPriority" desc:"Allow block priority in legacy protocol" default:"false" category:"Legacy" usage:"Enable for legacy block priority handling" type:"bool" longdesc:"### Purpose\nControls whether the node respects block priority hints embedded in legacy protocol messages.\n\n### How It Works\nLegacy Bitcoin protocol includes priority hints that suggest block processing order. When enabled:\n- Priority hints from peers are honored\n- Blocks may be processed out of arrival order based on hints\n- Can improve sync performance in specific scenarios\n\n### Options\n- **true** - Honor block priority hints from legacy peers\n- **false** - Process blocks in standard arrival order\n\n### Trade-offs\n- **Enabled** - Potentially faster sync, peers can influence processing order\n- **Disabled** - Predictable processing, immune to priority manipulation\n\n### Recommendations\n- Keep disabled unless specifically needed for legacy sync scenarios\n- Default of false prevents potential priority-based attacks"`
	GRPCListenAddress                string        `key:"legacy_grpcListenAddress" desc:"gRPC listen address for Legacy service" default:"" category:"Legacy" usage:"Port for incoming legacy gRPC connections" type:"string" longdesc:"### Purpose\nSpecifies the address where the legacy service listens for incoming gRPC connections from other Teranode services.\n\n### How It Works\nThe legacy service exposes its internal API on this address, allowing other microservices to:\n- Query legacy peer state\n- Submit transactions for legacy propagation\n- Access legacy-specific functionality\n\n### Options\n- **host:port format** - Address to bind the gRPC server\n- **Empty string** - Legacy gRPC server disabled\n\n### Recommendations\n- Bind to internal network interfaces only\n- Use **0.0.0.0:port** for container deployments\n- Pair with **GRPCAddress** for bidirectional communication"`
	SavePeers                        bool          `key:"legacy_savePeers" desc:"Persist legacy peer list to disk" default:"false" category:"Legacy" usage:"Enable for peer persistence across restarts" type:"bool" longdesc:"### Purpose\nControls whether discovered legacy peer addresses are saved to disk for use across node restarts.\n\n### How It Works\nWhen enabled:\n- Peer addresses discovered during operation are written to disk\n- On restart, saved peers are loaded immediately\n- Reduces time needed to establish network connectivity\n\nPeer data is stored in the **WorkingDir** location.\n\n### Options\n- **true** - Persist peers to disk\n- **false** - Peers discovered fresh each startup\n\n### Trade-offs\n- **Enabled** - Faster startup, requires disk write permissions\n- **Disabled** - Clean slate each start, no stale peer data\n\n### Recommendations\n- Enable for production nodes with stable peer networks\n- Disable for ephemeral/test deployments\n- Periodically clean peer database to remove stale entries"`
	AllowSyncCandidateFromLocalPeers bool          `key:"legacy_allowSyncCandidateFromLocalPeers" desc:"Allow sync candidate from local peers" default:"false" category:"Legacy" usage:"Enable for local network sync" type:"bool" longdesc:"### Purpose\nControls whether peers on local/private networks are considered as blockchain sync candidates.\n\n### How It Works\nBy default, the node excludes local network peers (RFC1918 addresses) from sync candidate selection as a security measure. When enabled:\n- Local network peers can be chosen for initial block download\n- Private testnet setups work correctly\n- Development environments can sync without public peers\n\n### Options\n- **true** - Local network peers eligible for sync\n- **false** - Only public network peers eligible for sync\n\n### Use Cases\n- Private/isolated blockchain networks\n- Development and testing environments\n- Air-gapped deployments\n\n### Recommendations\n- **Keep disabled for mainnet** - Prevents local network attacks\n- Enable only for private networks and testing\n- Combine with **ConnectPeers** for controlled sync sources"`
	TempStore                        *url.URL      `key:"temp_store" desc:"Temporary storage URL for legacy operations" default:"file://./data/tempstore" category:"Legacy" usage:"Temporary data storage location" type:"url" longdesc:"### Purpose\nSpecifies the storage location for temporary data generated during legacy protocol operations.\n\n### How It Works\nTemporary storage is used for:\n- Intermediate block processing data\n- Transaction validation scratch space\n- Protocol message buffering\n\n### Options\n- **file://path** - Local filesystem storage\n- Other URL schemes supported by the blob store\n\n### Examples\n| Value | Description |\n|-------|-------------|\n| file://./data/tempstore | Relative path (default) |\n| file:///var/teranode/temp | Absolute path |\n\n### Recommendations\n- Use fast storage (SSD) for better performance\n- Ensure sufficient space for block processing\n- Configure automatic cleanup or use tmpfs for ephemeral data"`
	PeerIdleTimeout                  time.Duration `key:"legacy_peerIdleTimeout" desc:"Timeout for idle legacy peers" default:"125s" category:"Legacy" usage:"Disconnect after this idle time (ping interval is 2 mins)" type:"duration" longdesc:"### Purpose\nDefines the maximum time a legacy peer connection can remain idle before being disconnected.\n\n### How It Works\nThe Bitcoin protocol uses a 2-minute ping/pong mechanism to detect dead connections. This timeout:\n- Starts counting from last message received\n- Resets on any incoming protocol message\n- Triggers disconnection when exceeded\n\n### Trade-offs\n- **Higher timeout** - More tolerant of network issues, slower detection of dead peers\n- **Lower timeout** - Faster cleanup of dead connections, may disconnect slow peers prematurely\n\n### Recommendations\n- Default of 125 seconds provides buffer above 2-minute ping interval\n- Account for network jitter and latency\n- Increase for high-latency network conditions\n- Do not set below 120 seconds (ping interval)"`
	PeerProcessingTimeout            time.Duration `key:"legacy_peerProcessingTimeout" desc:"Timeout for processing legacy peer messages" default:"3m" category:"Legacy" usage:"Maximum time for processing block messages" type:"duration" longdesc:"### Purpose\nDefines the maximum time allowed to process a single legacy protocol message before timing out.\n\n### How It Works\nSome protocol messages, particularly large blocks, can take significant time to process. This timeout:\n- Applies per-message during processing\n- Prevents indefinite hangs on malformed data\n- Protects against slow-loris style attacks\n\n### Trade-offs\n- **Higher timeout** - Accommodates larger blocks, slower detection of stuck processing\n- **Lower timeout** - Faster failure detection, may timeout on legitimate large blocks\n\n### Recommendations\n- Default of 3 minutes handles most block sizes\n- Increase for networks with very large blocks\n- Monitor for timeout errors in logs to adjust\n- Consider hardware performance when tuning"`
}
