package settings

import (
	"net/url"
	"time"
)

// SubtreeValidationSettings configures the Merkle subtree validation service.
type SubtreeValidationSettings struct {
	QuorumPath                                string              `key:"subtree_quorum_path" desc:"Path for quorum configuration" default:"" category:"SubtreeValidation" usage:"Location of quorum configuration file" type:"string" longdesc:"### Purpose\nSpecifies the file path to quorum configuration for subtree validation consensus.\n\n### How It Works\nQuorum configuration defines which validators must agree for a subtree to be considered valid. The configuration file specifies validator endpoints and quorum thresholds for Byzantine fault tolerance.\n\n### Recommendations\n- **Multi-validator deployments** - Provide path to quorum configuration for fault tolerance\n- **Single-validator setups** - Leave empty (no quorum needed)"`
	QuorumAbsoluteTimeout                     time.Duration       `key:"subtree_quorum_absolute_timeout" desc:"Absolute timeout for subtree quorum" default:"30s" category:"SubtreeValidation" usage:"Maximum wait for quorum agreement" type:"duration" longdesc:"### Purpose\nSets the maximum time to wait for quorum agreement on subtree validation.\n\n### How It Works\nWhen multiple validators participate in subtree validation, they must reach agreement within this timeout. If quorum is not reached, validation fails and the subtree is rejected.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Shorter | Faster failure detection | May timeout on slow networks |\n| Longer | More tolerant of latency | Slower failure recovery |\n\n### Recommendations\n- **30s** (default) - Reasonable for most distributed deployments\n- Increase for high-latency or geographically distributed validators"`
	SubtreeStore                              *url.URL            `key:"subtreestore" desc:"URL for subtree storage backend" default:"" category:"SubtreeValidation" usage:"Where validated subtrees are stored" type:"url" longdesc:"### Purpose\nSpecifies the storage backend URL for validated subtree data.\n\n### Format\n- **file://** - Local filesystem storage\n- **s3://** - Amazon S3 or compatible cloud storage\n\n### How It Works\nAfter successful validation, subtrees are stored at this location. The Asset Server retrieves subtrees from this store to serve syncing peers.\n\n### Recommendations\n- Use **file://** for local development or single-node deployments\n- Use **s3://** for production multi-node deployments with shared storage"`
	GetMissingTransactions                    int                 `key:"subtreevalidation_getMissingTransactions" desc:"Concurrency for fetching missing transactions" default:"auto" category:"SubtreeValidation" usage:"Parallel missing transaction fetches (auto = NumCPU/2)" type:"int" longdesc:"### Purpose\nControls the number of concurrent workers fetching missing transactions during subtree validation.\n\n### How It Works\nWhen a subtree references transactions not in the local cache, multiple workers fetch them from peers in parallel batches. Each worker handles a batch of transaction requests.\n\n### Values\n- **auto** (default) - Uses NumCPU/2 for balanced performance\n- **N > 0** - Fixed number of workers\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | Faster transaction retrieval | Higher network and peer load |\n| Lower | Reduced resource usage | Slower subtree validation |\n\n### Recommendations\n- Use **auto** for most deployments\n- Set explicitly for resource-constrained environments"`
	GRPCAddress                               string              `key:"subtreevalidation_grpcAddress" desc:"gRPC address for Subtree Validation service" default:"localhost:8089" category:"SubtreeValidation" usage:"Address for inter-service communication" type:"string" longdesc:"### Purpose\nSpecifies the client connection address for the Subtree Validation gRPC service.\n\n### Format\n**host:port** - Where host is a hostname, IP address, or DNS name.\n\n### Examples\n- **localhost:8089** - Local development (default)\n- **subtreevalidation.internal:8089** - Internal DNS\n- **10.0.1.51:8089** - Direct IP address\n\n### Recommendations\n- Use internal DNS or service mesh addresses in production\n- Use localhost only for local development"`
	GRPCListenAddress                         string              `key:"subtreevalidation_grpcListenAddress" desc:"gRPC listen address for Subtree Validation service" default:":8089" category:"SubtreeValidation" usage:"Port for incoming gRPC connections" type:"string" longdesc:"### Purpose\nSpecifies the server binding address for the Subtree Validation gRPC service.\n\n### Format\n- **:port** - Binds to all network interfaces\n- **ip:port** - Binds to a specific interface\n\n### Examples\n- **:8089** - Listen on all interfaces (default)\n- **127.0.0.1:8089** - Listen only on localhost\n- **10.0.1.51:8089** - Listen on specific interface\n\n### Recommendations\n- Use **:port** format for containerized deployments\n- Bind to specific IP for security in multi-tenant environments"`
	ProcessTxMetaUsingCacheBatchSize          int                 `key:"subtreevalidation_processTxMetaUsingCache_BatchSize" desc:"Batch size for processing transaction metadata from cache" default:"1024" category:"SubtreeValidation" usage:"Transactions per batch when using cache" type:"int" longdesc:"### Purpose\nControls how many transaction metadata records are processed per batch from cache.\n\n### How It Works\nTransaction metadata is read from cache in batches to optimize memory access patterns and reduce overhead.\n\n### Recommendations\n- **1024** (default) - Efficient for typical cache implementations\n- Adjust based on cache line sizes and memory architecture"`
	ProcessTxMetaUsingCacheConcurrency        int                 `key:"subtreevalidation_processTxMetaUsingCache_Concurrency" desc:"Concurrency for processing transaction metadata from cache" default:"32" category:"SubtreeValidation" usage:"Parallel cache operations" type:"int" longdesc:"### Purpose\nControls the number of parallel workers processing transaction metadata from cache.\n\n### How It Works\nMultiple goroutines process cached metadata concurrently. Cache operations are typically fast, allowing high concurrency.\n\n### Recommendations\n- **32** (default) - High throughput for typical cache performance\n- Increase for systems with very fast cache access\n- Decrease if experiencing cache contention"`
	ProcessTxMetaUsingCacheMissingTxThreshold int                 `key:"subtreevalidation_processTxMetaUsingCache_MissingTxThreshold" desc:"Threshold for missing transactions when using cache" default:"1" category:"SubtreeValidation" usage:"Switch to store after this many cache misses" type:"int" longdesc:"### Purpose\nDefines when to switch from cache-based to store-based processing based on cache misses.\n\n### How It Works\nWhen processing transaction metadata, if cache misses exceed this threshold, the system falls back to store-based processing.\n\n### Values\n- **1** (default) - Fall back on any cache miss (strict)\n- **N > 1** - Tolerate N cache misses before switching\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Lower | Consistent performance | More store fallbacks |\n| Higher | Maximizes cache use | Potential for slow mixed-mode processing |"`
	SubtreeDAHConcurrency                     int                 `key:"subtreevalidation_subtreeDAHConcurrency" desc:"Concurrency for subtree DAH operations" default:"8" category:"SubtreeValidation" usage:"Parallel DAH operations for subtrees" type:"int" longdesc:"### Purpose\nControls the number of parallel workers for Delete-At-Height (DAH) operations on subtrees.\n\n### How It Works\nDAH marks subtrees for eventual pruning at a specified block height. Multiple workers can update DAH markers concurrently to improve throughput.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | Faster DAH updates | More storage I/O |\n| Lower | Reduced storage load | Slower DAH processing |\n\n### Recommendations\n- **8** (default) - Good balance for most storage systems\n- Increase for high-IOPS storage systems"`
	TxMetaCacheEnabled                        bool                `key:"subtreevalidation_txMetaCacheEnabled" desc:"Enable transaction metadata caching" default:"true" category:"SubtreeValidation" usage:"Improves validation performance" type:"bool" longdesc:"### Purpose\nEnables in-memory caching of transaction metadata for faster validation.\n\n### How It Works\n- Cache is populated from the Kafka txmeta topic\n- Cache hits avoid expensive database lookups to the UTXO store\n- Essential for achieving high-throughput validation\n\n### Values\n- **true** (default) - Enable caching for production performance\n- **false** - Disable caching (debugging or extreme memory constraints only)\n\n### Recommendations\n- Keep enabled for all production deployments\n- Only disable for debugging cache-related issues"`
	TxMetaCacheMaxMB                          int                 `key:"txMetaCacheMaxMB" desc:"Maximum memory for transaction metadata cache" default:"256" category:"SubtreeValidation" usage:"Increase for better validation performance" type:"int" longdesc:"### Purpose\nSets the maximum memory in megabytes for the transaction metadata cache.\n\n### How It Works\nLarger cache size improves hit rate by retaining more transaction metadata, reducing database lookups during subtree validation.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | Better cache hit rate | More memory usage |\n| Lower | Less memory usage | More database queries |\n\n### Recommendations\n- **256** (default) - Suitable for most deployments\n- Increase for high-throughput nodes with available memory\n- Monitor cache hit rate metrics to optimize"`
	TxChanBufferSize                          int                 `key:"subtreevalidation_txChanBufferSize" desc:"Buffer size for transaction channel" default:"0" category:"SubtreeValidation" usage:"Channel buffer for transaction processing" type:"int" longdesc:"### Purpose\nSets the buffer size for internal transaction processing channels.\n\n### How It Works\nControls the Go channel buffer size used for passing transactions between processing stages.\n\n### Values\n- **0** (default) - Unbuffered channels for synchronous processing\n- **N > 0** - Buffered channels for pipelined processing\n\n### Recommendations\n- **0** - Default for most deployments (simpler flow control)\n- Increase for pipelining when producer and consumer have variable processing times"`
	BatchMissingTransactions                  bool                `key:"subtreevalidation_batch_missing_transactions" desc:"Batch missing transaction fetches" default:"true" category:"SubtreeValidation" usage:"Enable to batch missing transaction requests" type:"bool" longdesc:"### Purpose\nEnables batching of missing transaction fetches instead of individual queries.\n\n### How It Works\n- When enabled, missing transactions are collected and fetched in batches\n- When disabled, each missing transaction is fetched individually\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Enabled | Reduced database overhead | Latency for batch collection |\n| Disabled | Lower per-request latency | More database queries |\n\n### Recommendations\n- **true** (default) - Better performance for most deployments\n- Disable only for debugging or specific latency requirements"`
	SpendBatcherSize                          int                 `key:"subtreevalidation_spendBatcherSize" desc:"Batch size for spend operations" default:"1024" category:"SubtreeValidation" usage:"Number of spends per batch" type:"int" longdesc:"### Purpose\nControls how many UTXO spend operations are batched together during subtree processing.\n\n### How It Works\nWhen validating transactions, UTXO spends are collected and sent to the UTXO store in batches. This also controls the concurrency limit for parallel transaction processing (SpendBatcherSize * 2).\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Larger | Fewer database round-trips | Higher memory per batch |\n| Smaller | Lower memory usage | More database overhead |\n\n### Recommendations\n- **1024** (default) - Good balance for Aerospike performance\n- Adjust based on UTXO store characteristics"`
	MissingTransactionsBatchSize              int                 `key:"subtreevalidation_missingTransactionsBatchSize" desc:"Batch size for fetching missing transactions" default:"16384" category:"SubtreeValidation" usage:"Number of transactions per batch fetch" type:"int" longdesc:"### Purpose\nControls the maximum number of missing transactions fetched in a single batch operation from peers.\n\n### How It Works\nWhen transactions are missing during subtree validation, they are requested from peers in batches of this size to balance network efficiency with memory usage.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Larger | Fewer HTTP round-trips | Higher memory per batch |\n| Smaller | Lower memory usage | More network requests |\n\n### Recommendations\n- **16384** (default) - Optimized for typical subtree sizes\n- Reduce if memory constrained\n- Increase for high-latency peer connections"`
	PercentageMissingGetFullData              float64             `key:"subtreevalidation_percentageMissingGetFullData" desc:"Percentage threshold for fetching full data" default:"20" category:"SubtreeValidation" usage:"If more than this % missing, fetch full data" type:"float64" longdesc:"### Purpose\nSets the percentage threshold for switching from individual transaction fetches to full subtree data fetch.\n\n### How It Works\nWhen validating a subtree, if the percentage of missing transactions exceeds this threshold, the system fetches the complete subtree data file instead of individual transactions. This optimizes network usage when most transactions are missing.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Lower | Earlier switch to bulk fetch | May fetch unnecessary data |\n| Higher | More selective fetching | More round-trips when many missing |\n\n### Recommendations\n- **20** (default) - Good balance for typical scenarios\n- Increase for nodes with high cache hit rates\n- Decrease for syncing nodes that are catching up"`
	BlacklistedBaseURLs                       map[string]struct{} `key:"subtreevalidation_blacklisted_baseurls" desc:"Blacklisted base URLs for subtree validation (pipe-separated)" default:"" category:"SubtreeValidation" usage:"URLs to reject for security" type:"map[string]struct{}" longdesc:"### Purpose\nSpecifies base URLs that should be rejected for subtree fetching.\n\n### How It Works\nWhen peers provide base URLs for fetching subtree data, URLs in this blacklist are rejected. This prevents fetching data from known malicious or unreliable sources.\n\n### Format\nPipe-separated list of URLs (e.g., \"http://bad1.example.com|http://bad2.example.com\")\n\n### Recommendations\n- Add URLs of known malicious peers\n- Add URLs that consistently provide invalid data\n- Leave empty for normal operation"`
	BlockHeightRetentionAdjustment            int32               `key:"subtreevalidation_blockHeightRetentionAdjustment" desc:"Adjustment to global block height retention" default:"0" category:"SubtreeValidation" usage:"Can be positive or negative" type:"int32" longdesc:"### Purpose\nAdjusts the global retention policy specifically for subtree data.\n\n### How It Works\nThe Delete-At-Height (DAH) for subtrees is calculated as: global_retention + this_adjustment. This allows subtree data to be retained longer or pruned sooner than the global setting.\n\n### Values\n- **0** (default) - Use global retention setting\n- **Positive** - Keep subtrees longer than global setting\n- **Negative** - Prune subtrees sooner than global setting\n\n### Recommendations\n- **0** - For most deployments\n- Positive values for nodes serving historical data to syncing peers\n- Negative values only if subtree storage is constrained"`
	OrphanageTimeout                          time.Duration       `key:"subtreevalidation_orphanageTimeout" desc:"Timeout for orphan transactions in orphanage" default:"15m" category:"SubtreeValidation" usage:"How long to keep orphan transactions" type:"duration" longdesc:"### Purpose\nSets the maximum time to hold orphan transactions (those with missing parent transactions) before eviction.\n\n### How It Works\nWhen a transaction references a parent that is not yet available, it is stored in the orphanage. If the parent does not arrive within this timeout, the orphan is dropped.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Longer | More time for parents to arrive | Higher memory usage |\n| Shorter | Lower memory usage | May drop valid orphans prematurely |\n\n### Recommendations\n- **15m** (default) - Reasonable for typical network conditions\n- Increase for slow networks or during initial sync\n- Decrease if orphanage memory usage is a concern"`
	OrphanageMaxSize                          int                 `key:"subtreevalidation_orphanageMaxSize" desc:"Maximum transactions in orphanage" default:"100000" category:"SubtreeValidation" usage:"Prevents memory exhaustion from orphans" type:"int" longdesc:"### Purpose\nLimits the maximum number of orphan transactions held in memory.\n\n### How It Works\nWhen the orphanage reaches this limit, new orphan transactions are rejected. This prevents memory exhaustion during network issues or when receiving blocks out of order.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | Accommodates more orphans | Higher memory usage |\n| Lower | Lower memory usage | May reject valid orphans |\n\n### Recommendations\n- **100000** (default) - Handles typical orphan scenarios\n- Increase for nodes with ample memory during initial sync\n- Decrease for memory-constrained environments"`
	CheckBlockSubtreesConcurrency             int                 `key:"subtreevalidation_check_block_subtrees_concurrency" desc:"Concurrency limit for CheckBlockSubtrees operations" default:"32" category:"SubtreeValidation" usage:"Parallel subtree check operations" type:"int" longdesc:"### Purpose\nControls the number of parallel workers for checking block subtrees during validation.\n\n### How It Works\nWhen validating a block, subtrees are loaded and processed in parallel. Each worker handles one subtree, fetching data from storage or peers as needed.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | Faster block validation | More CPU, memory, and network usage |\n| Lower | Lower resource usage | Slower block validation |\n\n### Recommendations\n- **32** (default) - Good balance for most multi-core systems\n- Increase for systems with high-IOPS storage\n- Decrease for resource-constrained environments"`
	PauseTimeout                              time.Duration       `key:"subtreevalidation_pauseTimeout" desc:"Maximum duration for subtree processing pauses" default:"5m" category:"SubtreeValidation" usage:"Maximum pause during block validation" type:"duration" longdesc:"### Purpose\nSets the maximum duration that subtree processing can be paused during block validation coordination.\n\n### How It Works\nDuring block validation, subtree processing may be paused to coordinate with other services. This timeout prevents indefinite pauses that would stall validation.\n\n### Recommendations\n- **5m** (default) - Allows for coordination of large blocks\n- Increase for very large blocks or slow systems\n- Decrease to fail faster if coordination should be quick"`
	TxBatchSize                               int                 `key:"subtreevalidation_check_block_subtrees_tx_batch_size" desc:"Transaction batch size for CheckBlockSubtrees" default:"1048576" category:"SubtreeValidation" usage:"0 = no batching, otherwise batch size" type:"int" longdesc:"### Purpose\nControls the number of transactions processed per batch during CheckBlockSubtrees operations.\n\n### How It Works\nWhen validating blocks with many subtrees, transactions are grouped into batches to manage memory usage. The batch size determines how many subtrees are loaded at once based on their transaction count.\n\n### Values\n- **0** - Disable batching, process all subtrees at once\n- **1048576** (default) - Process approximately 1M transactions per batch\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Larger | Fewer batch transitions | Higher memory usage |\n| Smaller | Lower memory usage | More batch transitions |\n\n### Recommendations\n- **1048576** (default) - Good balance for most systems\n- Reduce for memory-constrained environments\n- Set to 0 for small blocks to avoid batching overhead"`
	UseOrderedLevelAlgorithm                  bool                `key:"subtreevalidation_useOrderedLevelAlgorithm" desc:"Use optimized ordered level algorithm" default:"true" category:"SubtreeValidation" usage:"Assumes transactions are ordered for O(V*I) complexity" type:"bool" longdesc:"### Purpose\nEnables an optimized algorithm that assumes transactions are topologically ordered within subtrees.\n\n### How It Works\nThe Bitcoin protocol mandates that transactions within a block are ordered such that parent transactions appear before their children. When enabled, the algorithm exploits this ordering to calculate dependency levels in a single pass.\n\n### Values\n- **true** (default) - Use optimized O(V*I) algorithm\n- **false** - Use standard O(V*E + V^2) algorithm\n\nWhere V = transactions, I = average inputs per transaction, E = dependencies.\n\n### Recommendations\n- **true** (default) - For all compliant block sources\n- Set to **false** only when receiving blocks from non-compliant sources with unordered transactions"`
}
