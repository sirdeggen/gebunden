package settings

import (
	"time"
)

// PostgresSettings configures PostgreSQL database connection pooling.
type PostgresSettings struct {
	MaxOpenConns     int           `key:"postgres_maxOpenConns" desc:"Maximum number of open database connections" default:"50" category:"Postgres" usage:"Adjust based on database server capacity" type:"int" longdesc:"### Purpose\nControls the upper limit of concurrent PostgreSQL database connections, affecting throughput and database server load.\n\n### How It Works\nThe connection pool maintains up to this many simultaneous connections. Each connection consumes memory on both client (~10KB) and server (~10MB with work_mem). Connections are reused across requests to avoid setup overhead.\n\n### Sizing Formula\n**max_connections_per_service** x **number_of_service_instances** should be less than **postgres_max_connections** minus reserved connections.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | More concurrent queries | Database memory exhaustion |\n| Lower | Reduced resource usage | Operations queue, causing latency |\n\n### Recommendations\n| Environment | Suggested Value |\n|-------------|----------------|\n| Development | 10-25 |\n| Default | 50 |\n| Production | 100-500 |\n\nMonitor **InUse** vs **MaxOpenConns** in pool metrics to identify bottlenecks."`
	MaxIdleConns     int           `key:"postgres_maxIdleConns" desc:"Maximum number of idle connections in pool" default:"10" category:"Postgres" usage:"Should be less than maxOpenConns" type:"int" longdesc:"### Purpose\nControls how many pre-established connections remain ready for immediate use, avoiding connection setup latency.\n\n### How It Works\nIdle connections can be immediately used for new requests without TCP handshake and authentication overhead (~5-10ms savings). Connections exceeding this limit are closed. Idle connections are also closed after **ConnMaxIdleTime** to prevent staleness.\n\n### Values\nMust be less than or equal to **MaxOpenConns**.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | Reduced connection churn, faster response | More memory consumed |\n| Lower | Resources freed faster | Connection overhead during traffic bursts |\n\n### Recommendations\n- Set to approximately **20-50%** of MaxOpenConns for typical workloads\n- Production environments with bursty traffic benefit from higher idle pools\n- Default of **10** balances memory usage and connection reuse"`
	ConnMaxLifetime  time.Duration `key:"postgres_connMaxLifetime" desc:"Maximum time a connection can be reused" default:"5m" category:"Postgres" usage:"Helps prevent stale connections" type:"duration" longdesc:"### Purpose\nLimits how long a connection can be reused before being closed and replaced, ensuring connection freshness.\n\n### How It Works\nConnections are closed after this duration regardless of idle status. New requests get fresh connections. Does not forcibly close active connections - waits for operation completion. Works with database server **idle_in_transaction_session_timeout** settings.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Shorter (1-3m) | Fresher connections, catches DNS changes | More connection churn overhead |\n| Longer (10-30m) | Reduced setup overhead | Risk of stale connections, memory leaks |\n\n### Recommendations\n| Scenario | Suggested Value |\n|----------|----------------|\n| Default | 5m |\n| Stale connection issues | 1-3m |\n| High-throughput | 10-30m |"`
	ConnMaxIdleTime  time.Duration `key:"postgres_connMaxIdleTime" desc:"Maximum time a connection can remain idle" default:"1m" category:"Postgres" usage:"Reduces resource usage during low activity" type:"duration" longdesc:"### Purpose\nControls how long idle connections are kept before being closed, freeing resources during low-activity periods.\n\n### How It Works\nIdle connections exceeding this duration are closed and removed from the pool. Should be shorter than **ConnMaxLifetime** to ensure inactive connections are cleaned up first. Works with **MaxIdleConns** to manage pool size during varying traffic patterns.\n\n### Values\n- **> 0** - Close idle connections after this duration\n- **0** - Disable idle timeout (connections kept until lifetime expires)\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Shorter (30s) | Aggressive resource cleanup | More reconnection overhead during bursts |\n| Longer (5m) | Better for bursty traffic | More memory consumed during idle periods |\n\n### Recommendations\n| Scenario | Suggested Value |\n|----------|----------------|\n| Default | 1m |\n| Resource-constrained | 30s |\n| Bursty traffic | 5m |\n| Disable timeout | 0 |"`
	RetryMaxAttempts int           `key:"postgres_retryMaxAttempts" desc:"Maximum retry attempts for transient errors" default:"3" category:"Postgres" usage:"Increase for flaky networks" type:"int" longdesc:"### Purpose\nControls how many times a failed PostgreSQL operation is retried before returning an error.\n\n### How It Works\nTransient errors trigger a retry loop up to this count. Each retry waits for **RetryBaseDelay** plus jitter to reduce thundering herd effects.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | More resilience to transient issues | Longer time before failing fast |\n| Lower | Faster failure and visibility | More request failures during hiccups |\n\n### Recommendations\n| Scenario | Suggested Value |\n|----------|----------------|\n| Default | 3 |\n| Unstable network | 5-10 |\n| Latency-sensitive | 1-2 |"`
	RetryBaseDelay   time.Duration `key:"postgres_retryBaseDelay" desc:"Base delay for retry backoff" default:"100ms" category:"Postgres" usage:"Lower for fast recovery, higher to reduce load" type:"duration" longdesc:"### Purpose\nDefines the starting delay between retries for transient PostgreSQL errors.\n\n### How It Works\nThe retry loop uses this as the initial backoff, typically increasing delay with jitter for subsequent attempts.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Lower (25-50ms) | Faster recovery | More pressure during outages |\n| Higher (250-500ms) | Reduced load and contention | Slower recovery |\n\n### Recommendations\n| Scenario | Suggested Value |\n|----------|----------------|\n| Default | 100ms |\n| High contention | 250ms |\n| Low-latency | 50ms |"`
	RetryEnabled     bool          `key:"postgres_retryEnabled" desc:"Enable retries for transient errors" default:"false" category:"Postgres" usage:"Disable to fail fast" type:"bool" longdesc:"### Purpose\nTurns PostgreSQL retry behavior on or off for transient errors.\n\n### How It Works\nWhen disabled, operations return errors immediately without attempting retries. When enabled, retry limits and backoff are controlled by **RetryMaxAttempts** and **RetryBaseDelay**.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Enabled | More resilient to brief outages | Longer request latency on failure |\n| Disabled | Faster failure and simpler behavior | More errors on transient faults |\n\n### Recommendations\n- Keep enabled for production deployments\n- Disable in tests when you want deterministic failure behavior"`

	// Circuit Breaker Settings
	CircuitBreakerEnabled          bool          `key:"postgres_circuitBreakerEnabled" desc:"Enable circuit breaker for database operations" default:"false" category:"Postgres" usage:"Enable for production resilience" type:"bool" longdesc:"### Purpose\nEnables the circuit breaker pattern to provide fail-fast behavior during sustained database outages.\n\n### How It Works\nWhen enabled, the circuit breaker tracks consecutive infrastructure failures. After reaching the failure threshold within the failure window, it opens the circuit and immediately rejects requests for the cooldown period, preventing resource exhaustion from futile retries.\n\n### Circuit Breaker States\n1. **Closed** (normal): Requests pass through, failures tracked\n2. **Open** (failing): Fast-fail immediately, no DB calls attempted\n3. **Half-Open** (testing): Allow limited probe requests to test recovery\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Enabled | Fast failure during outages, resource protection | May reject requests during brief hiccups |\n| Disabled | All requests attempted | Resource exhaustion during outages |\n\n### Recommendations\n- Enable for production deployments\n- Disable for development/testing when you need deterministic behavior\n- All circuit breaker settings must be explicitly configured when enabled"`
	CircuitBreakerFailureThreshold int           `key:"postgres_circuitBreakerFailureThreshold" desc:"Consecutive failures before opening circuit" default:"5" category:"Postgres" usage:"Lower for faster failure detection, higher for tolerance" type:"int" longdesc:"### Purpose\nDefines how many consecutive infrastructure failures trigger circuit opening.\n\n### How It Works\nFailures must occur within the **CircuitBreakerFailureWindow** to count as consecutive. The circuit opens when this threshold is reached, rejecting all subsequent requests until cooldown expires.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Lower (3-5) | Faster detection of outages | May trigger on transient issues |\n| Higher (10+) | Tolerant of brief hiccups | Slower to detect real outages |\n\n### Recommendations\n| Scenario | Suggested Value |\n|----------|----------------|\n| Default | 5 |\n| Unstable network | 7-10 |\n| Critical service | 3-4 |"`
	CircuitBreakerHalfOpenMax      int           `key:"postgres_circuitBreakerHalfOpenMax" desc:"Successful probes required to close circuit" default:"3" category:"Postgres" usage:"Higher for more confidence in recovery" type:"int" longdesc:"### Purpose\nDefines how many successful probe requests are required to close the circuit after recovery.\n\n### How It Works\nWhen the circuit transitions from Open to Half-Open, this many successful requests must complete before the circuit fully closes. Any failure during Half-Open immediately reopens the circuit.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Lower (1-2) | Faster recovery | May close prematurely on flaky recovery |\n| Higher (5+) | High confidence in stability | Slower return to normal operation |\n\n### Recommendations\n| Scenario | Suggested Value |\n|----------|----------------|\n| Default | 3 |\n| Conservative | 5 |\n| Fast recovery | 1-2 |"`
	CircuitBreakerCooldown         time.Duration `key:"postgres_circuitBreakerCooldown" desc:"Duration circuit stays open before testing" default:"30s" category:"Postgres" usage:"Match expected DB recovery time" type:"duration" longdesc:"### Purpose\nDefines how long the circuit stays open before transitioning to Half-Open to test recovery.\n\n### How It Works\nAfter opening, the circuit rejects all requests for this duration. Once expired, it transitions to Half-Open and allows limited probe requests to test if the database has recovered.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Shorter (10-15s) | Faster recovery detection | More frequent probing of failing DB |\n| Longer (60s+) | Gives DB time to fully recover | Longer service unavailability |\n\n### Recommendations\n| Scenario | Suggested Value |\n|----------|----------------|\n| Default | 30s |\n| Fast-recovering DB | 10-15s |\n| Major outage protection | 60s |"`
	CircuitBreakerFailureWindow    time.Duration `key:"postgres_circuitBreakerFailureWindow" desc:"Time window for counting consecutive failures" default:"10s" category:"Postgres" usage:"Match your latency tolerance" type:"duration" longdesc:"### Purpose\nDefines the time window within which failures must occur to be counted as consecutive.\n\n### How It Works\nThe failure counter resets if no failure occurs within this window. This prevents old failures from contributing to circuit opening when they're separated by periods of success.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Shorter (5s) | Only recent failures count | May miss slow-building outages |\n| Longer (30s+) | Detects gradual degradation | May open on spread-out failures |\n\n### Recommendations\n| Scenario | Suggested Value |\n|----------|----------------|\n| Default | 10s |\n| High-throughput | 5s |\n| Low-traffic service | 30s |"`
}
