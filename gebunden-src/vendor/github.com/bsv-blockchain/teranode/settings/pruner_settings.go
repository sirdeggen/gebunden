package settings

import "time"

// PrunerSettings configures the data pruning service.
type PrunerSettings struct {
	GRPCListenAddress               string        `key:"pruner_grpcListenAddress" desc:"gRPC listen address for Pruner service" default:":8096" category:"Pruner" usage:"Port for incoming gRPC connections" type:"string" longdesc:"### Purpose\nSpecifies the server binding address for the Pruner gRPC service.\n\n### Format\n- **:port** - Binds to all network interfaces\n- **ip:port** - Binds to a specific interface\n\n### Examples\n- **:8096** - Listen on all interfaces (default)\n- **127.0.0.1:8096** - Listen only on localhost\n- **10.0.1.50:8096** - Listen on specific interface\n\n### Recommendations\n- Use **:port** format for containerized deployments\n- Bind to specific IP for security in multi-tenant environments"`
	GRPCAddress                     string        `key:"pruner_grpcAddress" desc:"gRPC address for Pruner service" default:"localhost:8096" category:"Pruner" usage:"Address for inter-service communication" type:"string" longdesc:"### Purpose\nSpecifies the client connection address for the Pruner gRPC service.\n\n### Format\n**host:port** - Where host is a hostname, IP address, or DNS name.\n\n### Examples\n- **localhost:8096** - Local development (default)\n- **pruner.internal:8096** - Internal DNS\n- **10.0.1.50:8096** - Direct IP address\n\n### Recommendations\n- Use internal DNS or service mesh addresses in production\n- Use localhost only for local development"`
	SkipDuringCatchup               bool          `key:"pruner_skipDuringCatchup" desc:"Skip pruning during blockchain catchup" default:"false" category:"Pruner" usage:"Prevents race conditions during catchup" type:"bool" longdesc:"### Purpose\nControls whether the pruner skips all operations during blockchain catchup (FSMStateCATCHINGBLOCKS state).\n\n### How It Works\n- When enabled, the pruner checks FSM state and skips all deletion operations during catchup\n- This prevents race conditions where block validation marks transactions as mined faster than the pruner can preserve their parents\n- Once the node transitions to FSMStateRUNNING, the pruner executes normally with Phase 1 (preservation) before Phase 2 (deletion)\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| true | Safe for any retention value, no race conditions | Temporary storage growth during catchup |\n| false (default) | Storage efficient during catchup | Only safe with retention >= 288 blocks |\n\n### Recommendations\n- **false** (default) - Recommended for production deployments with retention >= 288 blocks\n- Set to **true** for development/testing with aggressive retention values"`
	BlockAssemblyWaitTimeout        time.Duration `key:"pruner_blockAssemblyWaitTimeout" desc:"Maximum wait for Block Assembly before pruning" default:"10m" category:"Pruner" usage:"Skip pruning if BA not ready within timeout" type:"duration" longdesc:"### Purpose\nSets the maximum time to wait for Block Assembly service to be ready before proceeding with pruning operations.\n\n### How It Works\n- Pruner coordinates with Block Assembly to ensure it does not prune data still needed for mining\n- If Block Assembly is not ready within this timeout, pruning may skip or proceed with caution\n- Prevents pruning data that could be needed for block construction\n\n### Recommendations\n- **10m** (default) - Allows for service startup and catchup scenarios\n- Increase for environments with slower service initialization\n- Decrease if you need faster failure detection"`
	ConnectionPoolWarningThreshold  float64       `key:"pruner_connectionPoolWarningThreshold" desc:"Connection pool utilization warning threshold" default:"0.7" category:"Pruner" usage:"Warn when pool exceeds this percentage (0.0-1.0)" type:"float64" longdesc:"### Purpose\nSets the Aerospike connection pool utilization threshold that triggers warnings and auto-adjustment of pruner concurrency.\n\n### How It Works\n- Monitors the ratio of used connections to total pool size\n- When utilization exceeds this threshold, pruner auto-reduces chunk group limit to prevent exhaustion\n- Logs warnings to alert operators of potential connection pressure\n\n### Values\n- Range: **0.0** to **1.0** (percentage as decimal)\n- **0.7** (default) - Trigger at 70% utilization, provides early warning\n\n### Recommendations\n- **0.7** (default) - Good balance between resource utilization and safety margin\n- Lower values provide more headroom but may reduce throughput\n- Higher values maximize throughput but risk pool exhaustion"`
	BlockTrigger                    string        `key:"pruner_block_trigger" desc:"When to trigger pruning" default:"OnBlockPersisted" category:"Pruner" usage:"OnBlockPersisted (default) or OnBlockMined" type:"string" longdesc:"### Purpose\nControls when pruning operations are triggered based on block notifications.\n\n### How It Works\n- **OnBlockPersisted** (default) - Triggers on BlockPersisted notifications (default, coordinated with Block Persister)\n- **OnBlockMined** - Triggers on Block notifications with mined_set=true\n\n### Recommendations\n- **OnBlockPersisted** (default) - Use when Block Persister is deployed\n- **OnBlockMined** - Use when Block Persister is not available"`
	ForceIgnoreBlockPersisterHeight bool          `key:"pruner_force_ignore_block_persister_height" desc:"Force ignore block persister height" default:"false" category:"Pruner" usage:"Use Block notifications instead of persister height" type:"bool" longdesc:"### Purpose\nControls how the safe prune height is determined for pruning operations.\n\n### How It Works\n- **false** (default) - Uses BlockPersisted notifications from Block Persister for coordination\n- **true** - Ignores Block Persister height tracking; uses Block notifications with mined_set=true instead\n\n### Values\n- **false** (default) - Normal coordination with Block Persister\n- **true** - Force use of Block notifications\n\n### Recommendations\n- Use **false** when Block Persister is running normally\n- Enable **true** when Block Persister is not deployed or its height tracking is unreliable"`
	UTXODefensiveEnabled            bool          `key:"pruner_utxoDefensiveEnabled" desc:"Enable defensive checks before UTXO deletion" default:"false" category:"Pruner" usage:"Verify children are mined before deleting" type:"bool" longdesc:"### Purpose\nEnables additional defensive checks before deleting UTXO records to ensure data consistency.\n\n### How It Works\n- When enabled, verifies that ALL child transactions spending parent UTXOs are properly mined and stable (288 blocks deep)\n- Parents are only deleted when every spending child has been confirmed for the safety window\n- Prevents orphaning children by ensuring we never delete a parent while any spending child might be reorganized\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Enabled | Maximum data safety | Slower pruning, higher database load |\n| Disabled | Faster pruning | Relies on delete_at_height being set correctly |\n\n### Recommendations\n- **false** (default) - Normal operation with proper delete_at_height management\n- Enable during debugging or if experiencing data consistency issues"`
	UTXODefensiveBatchReadSize      int           `key:"pruner_utxoDefensiveBatchReadSize" desc:"Batch size for reading child transactions" default:"10000" category:"Pruner" usage:"During defensive UTXO pruning" type:"int" longdesc:"### Purpose\nControls the batch size when reading child transaction records during defensive UTXO pruning checks.\n\n### How It Works\n- Only used when UTXODefensiveEnabled=true\n- Child transactions are fetched from Aerospike in batches to verify their mined status\n- Larger batches reduce round-trips but consume more memory per batch\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Larger | Fewer database round-trips | Higher memory usage |\n| Smaller | Lower memory usage | More database queries |\n\n### Recommendations\n- **10000** (default) - Good balance for most systems\n- Reduce for memory-constrained environments\n- Increase for high-latency Aerospike clusters"`
	UTXOChunkSize                   int           `key:"pruner_utxoChunkSize" desc:"Records per chunk during UTXO pruning" default:"1000" category:"Pruner" usage:"Affects memory and batch operations" type:"int" longdesc:"### Purpose\nControls the number of UTXO records processed per chunk during pruning operations.\n\n### How It Works\n- Records from Aerospike partition queries are accumulated into chunks\n- Each chunk is processed as a unit (parent updates, deletions, external file cleanup)\n- Chunking prevents memory exhaustion when pruning large numbers of records\n- Also sets the RecordQueueSize for Aerospike query pipelining\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Larger | Faster processing, better batching | Higher memory per chunk |\n| Smaller | Lower memory usage | More processing overhead |\n\n### Recommendations\n- **1000** (default) - Balanced for most systems\n- Increase for faster pruning if memory allows\n- Decrease for memory-constrained environments"`
	UTXOChunkGroupLimit             int           `key:"pruner_utxoChunkGroupLimit" desc:"Maximum parallel chunk processing" default:"10" category:"Pruner" usage:"During UTXO pruning" type:"int" longdesc:"### Purpose\nControls the maximum number of UTXO chunks processed in parallel during pruning.\n\n### How It Works\n- Each partition worker uses an errgroup with this concurrency limit\n- Chunks are submitted to the errgroup for parallel processing\n- Higher values increase throughput but also increase Aerospike connection usage\n- May be auto-adjusted downward if connection pool utilization exceeds warning threshold\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | Faster pruning throughput | Higher database load, more connections |\n| Lower | Reduced database pressure | Slower pruning |\n\n### Recommendations\n- **10** (default) - Good parallelism without excessive load\n- Increase for powerful systems with large Aerospike connection pools\n- Decrease if experiencing connection pool exhaustion"`
	UTXOProgressLogInterval         time.Duration `key:"pruner_utxoProgressLogInterval" desc:"Interval for logging pruning progress" default:"30s" category:"Pruner" usage:"How often to log progress during UTXO pruning" type:"duration" longdesc:"### Purpose\nSets how often to log progress during UTXO pruning operations.\n\n### How It Works\nDuring long-running pruning operations, progress is logged at this interval to help operators monitor the operation without flooding logs.\n\n### Recommendations\n- **30s** (default) - Regular updates without excessive logging\n- Decrease for more frequent updates during debugging\n- Increase for quieter logs in stable environments"`
	UTXOPartitionQueries            int           `key:"pruner_utxoPartitionQueries" desc:"Number of parallel Aerospike partition queries" default:"0" category:"Pruner" usage:"0 = auto-detect based on CPU cores" type:"int" longdesc:"### Purpose\nControls the number of parallel partition workers when scanning Aerospike for prunable records.\n\n### How It Works\n- Aerospike keyspace is divided into 4096 partitions\n- This setting controls how many workers scan partitions in parallel\n- Each worker processes a range of partitions independently\n- Partition-based scanning achieves up to 100x performance improvement over sequential queries\n\n### Values\n- **0** (default) - Auto-detect based on CPU cores and Aerospike query-threads-limit\n- **N > 0** - Fixed number of partition workers (capped at 4096)\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | Faster scanning | More Aerospike load, more connections |\n| Lower | Reduced cluster pressure | Slower pruning |\n\n### Recommendations\n- Use **0** for automatic scaling based on available resources\n- Set explicitly to match your Aerospike cluster's capacity"`
	BlobDeletionEnabled             bool          `key:"pruner_blobDeletionEnabled" desc:"Enable blob deletion scheduling" default:"true" category:"Pruner" usage:"Enable deletion of expired blobs" type:"bool" longdesc:"### Purpose\nEnables scheduled deletion of blob store data (transactions and subtrees) based on Delete-At-Height (DAH) values.\n\n### How It Works\n- When enabled, pruner schedules deletions for blobs that have reached their DAH height\n- Works with all blob store types (file, S3, memory, etc.)\n- Deletion is triggered after BlobDeletionSafetyWindow blocks past the persister height\n\n### Recommendations\n- **true** (default) - Enable for normal operations\n- **false** - Disable if you want to retain all blob data indefinitely"`
	BlobDeletionSafetyWindow        uint32        `key:"pruner_blobDeletionSafetyWindow" desc:"Blocks to wait after persister before deletion" default:"10" category:"Pruner" usage:"Safety margin for blob deletion" type:"uint32" longdesc:"### Purpose\nNumber of blocks to wait after Block Persister height before deleting blobs.\n\n### How It Works\nProvides a safety margin to ensure persisted blocks are stable before deleting their associated blobs. Prevents deletion of data that might be needed during reorg scenarios.\n\n### Recommendations\n- **10** (default) - Good balance between storage and safety\n- Increase for deeper reorg protection\n- Decrease to free storage faster (not recommended)"`
	BlobDeletionBatchSize           int           `key:"pruner_blobDeletionBatchSize" desc:"Maximum deletions per trigger" default:"1000" category:"Pruner" usage:"Limits deletions per pruning cycle" type:"int" longdesc:"### Purpose\nMaximum number of blob deletions to process per pruning trigger.\n\n### How It Works\nLimits the number of deletions per cycle to prevent overwhelming the blob store and database. Remaining deletions are processed in subsequent triggers.\n\n### Recommendations\n- **1000** (default) - Good throughput without excessive load\n- Increase for faster cleanup if system can handle it\n- Decrease to reduce deletion load"`
	BlobDeletionMaxRetries          int           `key:"pruner_blobDeletionMaxRetries" desc:"Maximum retry attempts for failed deletions" default:"3" category:"Pruner" usage:"Retries for transient failures" type:"int" longdesc:"### Purpose\nMaximum number of retry attempts for failed blob deletions.\n\n### How It Works\nWhen a blob deletion fails (network error, temporary unavailability), the pruner retries up to this many times before logging an error.\n\n### Recommendations\n- **3** (default) - Good balance for transient failures\n- Increase for unreliable storage backends\n- Decrease for faster failure detection"`
}
