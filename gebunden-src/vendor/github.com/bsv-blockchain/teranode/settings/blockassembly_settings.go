package settings

import "time"

// BlockAssemblySettings configures the block assembly service for mining.
type BlockAssemblySettings struct {
	Disabled                             bool          `key:"blockassembly_disabled" desc:"Disable block assembly service" default:"false" category:"BlockAssembly" usage:"Set true for non-mining nodes" type:"bool" longdesc:"### Purpose\nCompletely disables the block assembly service when set to **true**.\n\n### Use Cases\n- **Relay nodes** - Only forward transactions\n- **Archive nodes** - Store historical data\n- **API-only nodes** - Serve blockchain queries\n\n### How It Works\nSaves significant resources by not tracking mempool or building block candidates.\n\n### Recommendations\nMining nodes and pool operators should keep this set to **false**."`
	GRPCAddress                          string        `key:"blockassembly_grpcAddress" desc:"gRPC address for Block Assembly service" default:"localhost:8085" category:"BlockAssembly" usage:"Address for inter-service communication" type:"string" longdesc:"### Purpose\nSpecifies the client connection address for the Block Assembly gRPC service.\n\n### Used By\n- **RPC** - For getminingcandidate calls\n- **Validator** - For transaction routing\n- **Mining pool software** - For block template requests\n\n### Format\n**host:port** - Where host is a hostname, IP address, or DNS name.\n\n### Recommendations\n- **Development:** Default localhost:8085 works for local setups\n- **Production:** Use internal DNS or service mesh address"`
	GRPCListenAddress                    string        `key:"blockassembly_grpcListenAddress" desc:"gRPC listen address for Block Assembly service" default:":8085" category:"BlockAssembly" usage:"Port for incoming gRPC connections" type:"string" longdesc:"### Purpose\nSpecifies the server binding address for the Block Assembly gRPC service.\n\n### Format\n- **:port** - Binds to all network interfaces\n- **ip:port** - Binds to a specific interface\n\n### Recommendations\n- Use **:port** format for containerized deployments\n- Bind to specific IP for security in multi-tenant environments\n- Default **:8085** listens on all interfaces\n\n**Note:** This is a critical endpoint for mining operations."`
	GRPCMaxRetries                       int           `key:"blockassembly_grpcMaxRetries" desc:"Maximum gRPC retry attempts" default:"3" category:"BlockAssembly" usage:"Retries for gRPC client calls" type:"int" longdesc:"### Purpose\nControls maximum retry attempts for outbound gRPC calls from Block Assembly to other services.\n\n### How It Works\n- Applies to transient failures like connection reset or deadline exceeded\n- Permanent failures fail immediately without retry\n\n### Target Services\n- **Blockchain** - Chain state queries\n- **Validator** - Transaction validation\n\n### Recommendations\n- **3** (default) - Provides reasonable reliability without excessive delay\n- Lower values for faster failure detection\n- Higher values for unreliable networks"`
	GRPCRetryBackoff                     time.Duration `key:"blockassembly_grpcRetryBackoff" desc:"Backoff duration between gRPC retries" default:"2s" category:"BlockAssembly" usage:"Wait time between retry attempts" type:"duration" longdesc:"### Purpose\nSets the base backoff duration between gRPC retry attempts.\n\n### How It Works\nAfter a transient failure, the service waits this duration before attempting again, allowing temporary issues to resolve.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Shorter | Faster recovery | Higher load during outages |\n| Longer | Reduced load | Slower recovery |\n\n### Recommendations\n- **2s** (default) - Good balance for most environments\n- **Total retry duration** ≈ GRPCMaxRetries × GRPCRetryBackoff"`
	LocalDAHCache                        string        `key:"blockassembly_localDAHCache" desc:"Path for local DAH cache" default:"" category:"BlockAssembly" usage:"Directory for caching DAH data" type:"string" longdesc:"### Purpose\nSpecifies local filesystem path for caching Directed Acyclic Hashgraph (DAH) data used in subtree construction.\n\n### How It Works\nSpeeds up repeated access to transaction ancestry data during block assembly by caching DAH data locally.\n\n### Values\n- **Empty string** (default) - Disables local caching\n- **Path value** - Enables caching at specified location\n\n### Recommendations\nSet to fast local storage path (**SSD recommended**) for production deployments."`
	MaxBlockReorgCatchup                 int           `key:"blockassembly_maxBlockReorgCatchup" desc:"Maximum blocks to catch up during reorg" default:"100" category:"BlockAssembly" usage:"Reorg catchup limit" type:"int" longdesc:"### Purpose\nLimits the maximum number of blocks Block Assembly will attempt to catch up during a chain reorganization.\n\n### How It Works\nPrevents excessive processing during deep reorgs by capping the number of blocks to process.\n\n### Recommendations\n- **100** (default) - Handles normal reorgs without excessive catchup\n- Increase for networks with deeper expected reorgs\n\n**Warning:** If reorg is deeper than this value, manual intervention or a restart may be required."`
	MaxBlockReorgRollback                int           `key:"blockassembly_maxBlockReorgRollback" desc:"Maximum blocks to roll back during reorg" default:"100" category:"BlockAssembly" usage:"Reorg rollback limit" type:"int" longdesc:"### Purpose\nLimits the maximum number of blocks to roll back mempool state during a reorganization.\n\n### How It Works\nTransactions from rolled-back blocks return to the mempool for re-inclusion.\n\n### Recommendations\n- **100** (default) - Handles significant reorgs\n- Deeper rollbacks may require special handling to preserve transaction state"`
	MoveBackBlockConcurrency             int           `key:"blockassembly_moveBackBlockConcurrency" desc:"Concurrency for moving transactions back to mempool" default:"375" category:"BlockAssembly" usage:"Parallel workers during reorg" type:"int" longdesc:"### Purpose\nControls the number of parallel workers moving transactions from rolled-back blocks back to the mempool during reorganization.\n\n### How It Works\nMultiple goroutines process transactions concurrently to maximize throughput during reorg recovery.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | Faster reorg processing | More CPU and memory usage |\n| Lower | Reduced resource usage | Slower reorg recovery |\n\n### Recommendations\n- **375** (default) - High concurrency for fast reorg processing\n- Adjust based on system resources (CPU, memory) and typical reorg depth"`
	ProcessRemainderTxHashesConcurrency  int           `key:"blockassembly_processRemainderTxHashesConcurrency" desc:"Concurrency for processing remainder transaction hashes" default:"375" category:"BlockAssembly" usage:"Parallel hash processing workers" type:"int" longdesc:"### Purpose\nControls the number of parallel workers processing remainder transaction hashes during subtree construction.\n\n### How It Works\nProcesses transactions not included in initial subtrees concurrently for high throughput.\n\n### Recommendations\n- **375** (default) - Enables high-throughput processing\n- Adjust based on CPU availability and storage IOPS"`
	SendBatchSize                        int           `key:"blockassembly_sendBatchSize" desc:"Batch size for sending transactions to validator" default:"100" category:"BlockAssembly" usage:"Transactions per batch" type:"int" longdesc:"### Purpose\nControls the number of transactions to batch before sending to downstream services during block assembly operations.\n\n### How It Works\nTransactions are accumulated until the batch size is reached, then sent together to reduce network overhead.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | Reduced network overhead | Higher memory usage, increased latency |\n| Lower | Lower latency | More network calls |\n\n### Recommendations\n- **100** (default) - Balances latency with batching efficiency"`
	SendBatchTimeout                     int           `key:"blockassembly_sendBatchTimeout" desc:"Timeout for send batch in seconds" default:"2" category:"BlockAssembly" usage:"Maximum wait before sending partial batch" type:"int" longdesc:"### Purpose\nSets the maximum seconds to wait for a batch to fill before sending a partially-filled batch.\n\n### How It Works\nWorks with SendBatchSize - whichever limit is reached first triggers the send. Ensures batches are sent promptly during low activity.\n\n### Recommendations\n- **2** (default) - Prompt sending during low activity\n- Increase for higher batching efficiency at the cost of latency"`
	SubtreeProcessorBatcherSize          int           `key:"blockassembly_subtreeProcessorBatcherSize" desc:"Batch size for subtree processor" default:"1000" category:"BlockAssembly" usage:"Records per subtree processing batch" type:"int" longdesc:"### Purpose\nControls the number of records to batch during subtree processing operations.\n\n### How It Works\nSubtrees are merkle tree fragments that enable parallel block validation. Records are batched to optimize memory and processing efficiency.\n\n### Recommendations\n- **1000** (default) - Balances memory with processing efficiency\n- Adjust based on available memory and processing requirements"`
	SubtreeProcessorConcurrentReads      int           `key:"blockassembly_subtreeProcessorConcurrentReads" desc:"Concurrent reads in subtree processor" default:"375" category:"BlockAssembly" usage:"Parallel subtree read operations" type:"int" longdesc:"### Purpose\nControls the number of concurrent read operations during subtree processing.\n\n### How It Works\nMultiple goroutines read subtree data concurrently to maximize throughput during block construction.\n\n### Recommendations\n- **375** (default) - Enables high-throughput subtree construction\n- Coordinate with your storage backend capacity when tuning this value"`
	NewSubtreeChanBuffer                 int           `key:"blockassembly_newSubtreeChanBuffer" desc:"Buffer size for new subtree channel" default:"1000" category:"BlockAssembly" usage:"Buffered subtree notifications" type:"int" longdesc:"### Purpose\nSets the buffer size for the channel receiving new subtree notifications.\n\n### How It Works\nBuffers allow subtree production to proceed without blocking on consumers during burst creation.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Larger | Handles bursts, no sender blocking | More memory usage |\n| Smaller | Lower memory | May block senders during bursts |\n\n### Recommendations\n- **1000** (default) - Handles burst subtree creation\n- Increase if seeing channel blocking during high-throughput block assembly"`
	SubtreeRetryChanBuffer               int           `key:"blockassembly_subtreeRetryChanBuffer" desc:"Buffer size for subtree retry channel" default:"1000" category:"BlockAssembly" usage:"Buffered retry notifications" type:"int" longdesc:"### Purpose\nSets the buffer size for the channel handling subtree processing retries.\n\n### How It Works\nFailed subtree operations are queued in this channel for retry processing.\n\n### Recommendations\n- **1000** (default) - Handles typical retry volume\n- Increase if seeing excessive retry queue blocking"`
	SubtreeStorageWorkers                int           `key:"blockassembly_subtreeStorageWorkers" desc:"Workers for subtree storage operations" default:"4" category:"BlockAssembly" usage:"Parallel storage workers" type:"int" longdesc:"### Purpose\nControls the number of workers handling subtree storage operations (writes to blockstore).\n\n### How It Works\nMultiple workers perform parallel I/O to maximize storage throughput.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | Faster storage throughput | May overwhelm storage backend |\n| Lower | Reduced storage pressure | Slower subtree persistence |\n\n### Recommendations\n- **4** (default) - Provides parallel I/O without overwhelming storage\n- Increase for faster storage backends\n- Decrease if storage is a bottleneck"`
	SubmitMiningSolutionWaitForResponse  bool          `key:"blockassembly_SubmitMiningSolution_waitForResponse" desc:"Wait for response after submitting mining solution" default:"true" category:"BlockAssembly" usage:"Synchronous solution submission" type:"bool" longdesc:"### Purpose\nControls whether SubmitMiningSolution call waits for the blockchain to process and respond before returning.\n\n### Values\n- **true** (default) - Ensures caller knows if solution was accepted\n- **false** - Fire-and-forget submission\n\n### Recommendations\n- **true** (default) - Required for production mining\n\n**Warning:** Setting to false is not recommended for production mining."`
	InitialMerkleItemsPerSubtree         int           `key:"initial_merkle_items_per_subtree" desc:"Initial transaction count per subtree" default:"1048576" category:"BlockAssembly" usage:"Starting subtree size" type:"int" longdesc:"### Purpose\nSets the initial number of transactions targeted per merkle subtree when building blocks.\n\n### How It Works\nBlock Assembly uses this as a starting point but may adjust based on actual transaction flow.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Larger | Fewer subtrees to manage | Larger individual subtree size |\n| Smaller | Finer granularity | More subtrees, increased overhead |\n\n### Recommendations\n- **1048576** (1M, default) - Provides reasonable subtree granularity"`
	MinimumMerkleItemsPerSubtree         int           `key:"minimum_merkle_items_per_subtree" desc:"Minimum transaction count per subtree" default:"1024" category:"BlockAssembly" usage:"Smallest allowed subtree" type:"int" longdesc:"### Purpose\nSets the minimum transactions allowed per subtree.\n\n### How It Works\nPrevents creating many tiny subtrees that increase overhead. Subtrees smaller than this value are merged with adjacent subtrees.\n\n### Recommendations\n- **1024** (default) - Ensures reasonable subtree efficiency"`
	MaximumMerkleItemsPerSubtree         int           `key:"maximum_merkle_items_per_subtree" desc:"Maximum transaction count per subtree" default:"1048576" category:"BlockAssembly" usage:"Largest allowed subtree" type:"int" longdesc:"### Purpose\nSets the maximum transactions allowed per subtree.\n\n### How It Works\nLimits individual subtree size to maintain parallel validation efficiency.\n\n### Recommendations\n- **1048576** (1M, default) - Balances subtree processing with parallelism\n\n**Note:** Very large subtrees reduce validation parallelism."`
	DoubleSpendWindow                    time.Duration `key:"double_spend_window_millis" desc:"Time window for double-spend detection" default:"0" category:"BlockAssembly" usage:"Milliseconds to track for double-spends" type:"duration" longdesc:"### Purpose\nSets the time window during which Block Assembly tracks potential double-spend attempts.\n\n### How It Works\nTransactions spending the same inputs within this window are flagged for special handling.\n\n### Values\n- **0** (default) - Disables windowed tracking\n- **Positive value** - Enables double-spend monitoring for the specified duration\n\n**Note:** Value is converted from milliseconds setting."`
	MaxGetReorgHashes                    int           `key:"blockassembly_maxGetReorgHashes" desc:"Maximum block hashes to return in reorg query" default:"10000" category:"BlockAssembly" usage:"Limits reorg hash response size" type:"int" longdesc:"### Purpose\nLimits the maximum number of block hashes returned in response to reorg-related queries.\n\n### How It Works\nPrevents excessive memory and network usage for deep reorg scenarios.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Larger | Supports deeper reorg analysis | Higher resource usage |\n| Smaller | Lower resource usage | May truncate deep reorg data |\n\n### Recommendations\n- **10000** (default) - Handles significant reorgs"`
	MinerWalletPrivateKeys               []string      `key:"miner_wallet_private_keys" desc:"Miner wallet private keys (pipe-separated)" default:"" category:"BlockAssembly" usage:"Keys for receiving mining rewards" type:"[]string" longdesc:"### Purpose\nSpecifies the private keys for wallets receiving mining rewards from coinbase transactions.\n\n### Format\n- **WIF format** (Wallet Import Format)\n- Multiple keys separated by pipe character (|)\n\n### How It Works\nRewards are distributed round-robin or according to configured strategy. For mining pools, these are typically pool collection addresses.\n\n### Recommendations\n**CRITICAL:** Secure these keys - they control all mining rewards."`
	DifficultyCache                      bool          `key:"blockassembly_difficultyCache" desc:"Enable difficulty target caching" default:"true" category:"BlockAssembly" usage:"Cache computed difficulty targets" type:"bool" longdesc:"### Purpose\nEnables caching of computed difficulty targets to avoid recalculation.\n\n### How It Works\nBitcoin difficulty adjusts every 2016 blocks. Caching saves computation by storing previously calculated targets.\n\n### Recommendations\n- **true** (default) - Recommended for efficiency\n- Disable only for debugging difficulty calculations"`
	UseDynamicSubtreeSize                bool          `key:"blockassembly_useDynamicSubtreeSize" desc:"Enable dynamic subtree sizing" default:"false" category:"BlockAssembly" usage:"Adapt subtree size to transaction rate" type:"bool" longdesc:"### Purpose\nEnables dynamic adjustment of subtree size based on transaction throughput and block assembly performance.\n\n### Values\n- **false** (default) - Uses fixed sizing from InitialMerkleItemsPerSubtree\n- **true** - Enables dynamic adjustment\n\n### Recommendations\nEnable for high-variability transaction environments to improve efficiency under varying loads."`
	MiningCandidateCacheTimeout          time.Duration `key:"blockassembly_miningCandidateCacheTimeout" desc:"Cache timeout for mining candidates" default:"5s" category:"BlockAssembly" usage:"How long candidates remain cached" type:"duration" longdesc:"### Purpose\nSets the time mining candidates remain in cache before expiration.\n\n### How It Works\nCached candidates can be reused for multiple miner requests, reducing generation overhead.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Longer | Reduces candidate generation | May serve stale data |\n| Shorter | Fresher candidates | More generation overhead |\n\n### Recommendations\n- **5s** (default) - Balances cache efficiency with candidate freshness"`
	MiningCandidateSmartCacheMaxAge      time.Duration `key:"blockassembly_miningCandidateSmartCacheMaxAge" desc:"Maximum age for smart-cached mining candidates" default:"10s" category:"BlockAssembly" usage:"Smart cache expiration" type:"duration" longdesc:"### Purpose\nSets the maximum age for candidates in the smart cache before forced regeneration.\n\n### How It Works\nThe smart cache considers chain tip changes and transaction additions when determining staleness. Candidates exceeding this age are regenerated.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Longer | Saves computation | Risk of stale candidates |\n| Shorter | Fresher candidates | More regeneration overhead |\n\n### Recommendations\n- **10s** (default) - Ensures candidates are reasonably fresh while benefiting from caching"`
	BlockchainSubscriptionTimeout        time.Duration `key:"blockassembly_blockchainSubscriptionTimeout" desc:"Timeout for blockchain event subscription" default:"5m" category:"BlockAssembly" usage:"Subscription renewal interval" type:"duration" longdesc:"### Purpose\nSets the timeout for blockchain service event subscriptions.\n\n### How It Works\nBlock Assembly subscribes to chain updates. Subscriptions are renewed before this timeout expires.\n\n### Recommendations\n- **5m** (default) - Allows long-running subscriptions with periodic renewal\n- Shorter values increase subscription overhead"`
	OnRestartValidateParentChain         bool          `key:"blockassembly_onRestartValidateParentChain" desc:"Validate parent chain on restart" default:"true" category:"BlockAssembly" usage:"Verify chain state at startup" type:"bool" longdesc:"### Purpose\nValidates parent block chain integrity on service restart when enabled.\n\n### How It Works\nEnsures Block Assembly state is consistent with the blockchain by validating the parent chain.\n\n### Recommendations\n- **true** (default) - Recommended for safety\n- Disable for faster restart if chain integrity is verified by other means"`
	ParentValidationBatchSize            int           `key:"blockassembly_parentValidationBatchSize" desc:"Batch size for parent chain validation" default:"1000" category:"BlockAssembly" usage:"Blocks per validation batch" type:"int" longdesc:"### Purpose\nControls the number of blocks to validate per batch during parent chain validation on restart.\n\n### How It Works\nBlocks are validated in batches to balance validation speed with memory usage.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | Faster validation | More memory usage |\n| Lower | Less memory | Slower validation |\n\n### Recommendations\n- **1000** (default) - Balances validation speed with memory usage"`
	OnRestartRemoveInvalidParentChainTxs bool          `key:"blockassembly_onRestartRemoveInvalidParentChainTxs" desc:"Remove invalid transactions on restart" default:"false" category:"BlockAssembly" usage:"Clean mempool on restart" type:"bool" longdesc:"### Purpose\nRemoves transactions with invalid parent chains from the mempool on restart when enabled.\n\n### How It Works\nCleans up orphaned or conflicting transactions during startup.\n\n### Values\n- **false** (default) - Preserves transactions for potential re-validation\n- **true** - Removes invalid transactions on startup\n\n### Recommendations\nEnable if experiencing mempool inconsistencies after restarts."`
	UseColumnarBatch                     bool          `key:"blockassembly_useColumnarBatch" desc:"Use columnar batch format" default:"false" category:"BlockAssembly" usage:"Optimize batch data layout" type:"bool" longdesc:"### Purpose\nEnables columnar data layout for batch operations instead of row-based.\n\n### How It Works\nColumnar layout organizes data by column rather than by row, potentially improving cache efficiency and enabling better SIMD operations for certain workloads.\n\n### Values\n- **false** (default) - Uses traditional row format\n- **true** - Enables columnar optimization\n\n### Recommendations\nEnable for experimentation with columnar optimization."`
	UnminedTxDiskSortPath                string        `key:"blockassembly_unminedTxDiskSortPath" desc:"Path for unmined transaction disk sorting" default:"" category:"BlockAssembly" usage:"Temp storage for large sorts" type:"string" longdesc:"### Purpose\nSpecifies the filesystem path for temporary storage during external sorting of unmined transactions.\n\n### How It Works\nUsed when mempool is too large for in-memory sorting.\n\n### Values\n- **Empty string** (default) - Disables disk-based sorting (memory only)\n- **Path value** - Enables external sort at specified location\n\n### Recommendations\nSet to fast local storage (**SSD**) for large mempools in production."`
	UnminedTxDiskSortEnabled             bool          `key:"blockassembly_unminedTxDiskSortEnabled" desc:"Enable disk-based sorting for unmined transactions" default:"false" category:"BlockAssembly" usage:"Use external sort for large mempools" type:"bool" longdesc:"### Purpose\nEnables disk-based external sort for ordering unmined transactions when UnminedTxDiskSortPath is configured.\n\n### How It Works\nWhen enabled, uses disk-based sorting instead of in-memory sorting for handling large mempools.\n\n### Values\n- **false** (default) - Uses in-memory sorting\n- **true** - Uses disk-based external sort\n\n### Recommendations\nEssential for very large mempools exceeding available memory."`
	UnminedLoadingBatchSize              int           `key:"blockassembly_unminedLoadingBatchSize" desc:"Batch size for loading unmined transactions" default:"10485760" category:"BlockAssembly" usage:"Records per load batch (10M default)" type:"int" longdesc:"### Purpose\nControls the number of unmined transactions to load per batch from storage.\n\n### How It Works\nTransactions are loaded in batches to balance efficiency with memory usage.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | Fewer loading iterations | More memory usage |\n| Lower | Better for memory-constrained systems | More loading iterations |\n\n### Recommendations\n- **10485760** (10 million, default) - Enables efficient bulk loading"`
	GetMiningCandidateSendTimeout        time.Duration `key:"blockassembly_getMiningCandidate_send_timeout" desc:"Send timeout for getMiningCandidate" default:"1s" category:"BlockAssembly" usage:"Network send timeout" type:"duration" longdesc:"### Purpose\nSets the timeout for sending getMiningCandidate response to the client.\n\n### How It Works\nLimits how long to wait when sending the response, which includes block template data that can be large.\n\n### Recommendations\n- **1s** (default) - Allows for network latency\n- Increase for slow networks\n- Decrease for faster timeout detection"`
	GetMiningCandidateResponseTimeout    time.Duration `key:"blockassembly_getMiningCandidate_response_timeout" desc:"Response timeout for getMiningCandidate" default:"10s" category:"BlockAssembly" usage:"Total operation timeout" type:"duration" longdesc:"### Purpose\nSets the total timeout for the getMiningCandidate operation including template generation.\n\n### How It Works\nLimits the total time for generating a mining candidate, including template construction.\n\n### Recommendations\n- **10s** (default) - Allows for complex template construction\n- Increase if templates regularly time out due to large mempool or slow storage"`
	SubtreeAnnouncementInterval          time.Duration `key:"blockassembly_subtreeAnnouncementInterval" desc:"Interval for subtree announcements" default:"10s" category:"BlockAssembly" usage:"How often to announce subtrees" type:"duration" longdesc:"### Purpose\nSets the interval between announcements of newly created subtrees to the P2P network.\n\n### How It Works\nAnnouncements help other nodes discover and fetch subtree data.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Shorter | Faster propagation | More network traffic |\n| Longer | Reduced overhead | Slower propagation |\n\n### Recommendations\n- **10s** (default) - Balances network traffic with timely propagation"`
	ParallelSetIfNotExistsThreshold      int           `key:"blockassembly_parallelSetIfNotExistsThreshold" desc:"Threshold for parallel set-if-not-exists operations" default:"10000" category:"BlockAssembly" usage:"When to parallelize conditional writes" type:"int" longdesc:"### Purpose\nSets the record count threshold above which set-if-not-exists operations are parallelized.\n\n### How It Works\n- **Below threshold** - Operations run sequentially\n- **Above threshold** - Operations run in parallel for improved throughput\n\n### Recommendations\n- **10000** (default) - Triggers parallel execution for large batches"`
	StoreTxInpointsForSubtreeMeta        bool          `key:"blockassembly_storeTxInpointsForSubtreeMeta" desc:"Store transaction input points in subtree metadata" default:"false" category:"BlockAssembly" usage:"Memory vs lookup tradeoff" type:"bool" longdesc:"### Purpose\nEnables storing transaction input points in subtree metadata.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Enabled | Speeds up certain lookups | Increases memory usage |\n| Disabled | Optimizes for memory | Requires lookups for input point data |\n\n### Recommendations\n- **false** (default) - Optimizes for memory\n- Enable if subtree operations frequently need input point data and sufficient memory is available"`
	IdleSleepDuration                    time.Duration `key:"blockassembly_idle_sleep_duration" desc:"Sleep duration when subtree processor queue is empty" default:"10ms" category:"BlockAssembly" usage:"Idle loop sleep time" type:"duration" longdesc:"### Purpose\nControls the sleep duration in the subtree processor worker loop when the transaction queue is empty.\n\n### How It Works\nWhen no transactions are pending, the processor sleeps for this duration before checking again, preventing excessive CPU usage from busy-waiting.\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Shorter | Lower latency for new transactions | Higher CPU usage when idle |\n| Longer | Lower CPU usage when idle | Higher latency for new transactions |\n\n### Recommendations\n- **10ms** (default) - Balances responsiveness with CPU efficiency"`
}
