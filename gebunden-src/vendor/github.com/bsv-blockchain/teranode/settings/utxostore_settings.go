package settings

import (
	"net/url"
	"time"
)

// UtxoStoreSettings configures the UTXO (Unspent Transaction Output) store.
type UtxoStoreSettings struct {
	UtxoStore                         *url.URL          `key:"utxostore" desc:"URL for UTXO store backend" default:"" category:"UtxoStore" usage:"Database URL for UTXO storage" type:"url" longdesc:"### Purpose\nSpecifies the URL for the UTXO store backend database.\n\n### Supported Backends\n- **aerospike://host:port/namespace/set** - Aerospike database\n- **postgres://user:pass@host/db** - PostgreSQL database\n\n### How It Works\nDefault empty uses Aerospike with settings from AerospikeSettings. Backend choice affects all UTXO operations: create, spend, lookup, and pruning.\n\n### Recommendations\n- **Aerospike** - Highest performance for UTXO operations, recommended for production\n- **PostgreSQL** - Useful for smaller deployments or when Aerospike is not available"`
	BlockHeightRetention              uint32            `key:"utxostore_blockHeightRetention" desc:"Number of blocks to retain UTXO data" default:"288" category:"UtxoStore" usage:"Approximately 2 days with 10-minute blocks" type:"uint32" longdesc:"### Purpose\nPrimary retention policy determining how long spent UTXO records remain in the database.\n\n### How It Works\nWhen all transaction outputs are spent, the record is marked with DeleteAtHeight = currentHeight + BlockHeightRetention. The DAH pruner later deletes records where DeleteAtHeight <= currentHeight.\n\n### Values\n- **Default 288 blocks** - Approximately 2 days, provides safety margin for blockchain reorganizations\n- **0** - Disables pruning entirely (causes unbounded database growth)\n- **>288** - Needed for services requiring longer transaction history like Asset Server\n\n### Related Settings\n- Can be adjusted per-service using **BlockHeightRetentionAdjustment**\n- Works with **PreserveUntil** mechanism to protect parent transactions of old unmined transactions"`
	UnminedTxRetention                uint32            `key:"utxostore_unminedTxRetention" desc:"Retention window for unmined transactions" default:"144" category:"UtxoStore" usage:"Blocks before parent preservation triggers" type:"uint32" longdesc:"### Purpose\nDefines the retention window before parent preservation triggers for unmined transactions.\n\n### How It Works\nWhen a transaction remains unmined for this duration (currentHeight - UnminedSince > UnminedTxRetention), Phase 1 pruning preserves its parent transactions to enable future resubmission.\n\n### Values\n- **Default 144 blocks** - Approximately 1 day, typically BlockHeightRetention/2\n\n### Critical Relationship\nUnminedTxRetention < BlockHeightRetention < ParentPreservationBlocks\n\n### Why This Matters\nWithout parent preservation, resubmitted unmined transactions would fail validation due to missing parent UTXOs. Works with **ParentPreservationBlocks** to implement two-phase safety mechanism."`
	ParentPreservationBlocks          uint32            `key:"utxostore_parentPreservationBlocks" desc:"Extended retention for parent transactions" default:"1440" category:"UtxoStore" usage:"Protection period for parent UTXOs" type:"uint32" longdesc:"### Purpose\nExtends retention for parent transactions of old unmined transactions.\n\n### How It Works\nWhen unmined transactions older than UnminedTxRetention are found, their parent transactions are marked PreserveUntil = currentHeight + ParentPreservationBlocks. This protects parent UTXOs from deletion during Phase 2 pruning, ensuring resubmitted unmined transactions can still be validated.\n\n### Values\n- **Default 1440 blocks** - Approximately 10 days, provides 10x safety margin over UnminedTxRetention\n- **Higher values** - Needed for networks with long mempool backlogs\n\n### Critical Behavior\n- Phase 1 (parent preservation) **must succeed** before Phase 2 (DAH cleanup) runs\n- If ANY parent update fails, entire pruning operation aborts\n\n### Warning\n**DO NOT reduce below 1440** as this risks invalidating legitimate transaction resubmissions."`
	OutpointBatcherSize               int               `key:"utxostore_outpointBatcherSize" desc:"Batch size for outpoint operations" default:"100" category:"UtxoStore" usage:"Number of outpoints per batch" type:"int" longdesc:"### Purpose\nControls the batch size for UTXO outpoint lookups (txid:vout to UTXO data).\n\n### How It Works\nBatcher accumulates individual requests and fires when size reached or OutpointBatcherDurationMillis elapsed, whichever occurs first. Single BatchGet operation to Aerospike instead of individual calls.\n\n### Values\n- **Default 100** - Provides 10-100x speedup for concurrent outpoint lookups\n- **200-500** - For high concurrency scenarios\n- **50** - For low-latency requirements\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Size | Controls throughput | Higher memory usage |\n| Duration | Controls latency | Lower batching efficiency |\n\nWorks in tandem with **OutpointBatcherDurationMillis**."`
	OutpointBatcherDurationMillis     int               `key:"utxostore_outpointBatcherDurationMillis" desc:"Batching window for outpoint operations in milliseconds" default:"10" category:"UtxoStore" usage:"Time to accumulate outpoint operations" type:"int" longdesc:"### Purpose\nSets the batching window in milliseconds for outpoint operations.\n\n### How It Works\nBatcher fires after this duration even if OutpointBatcherSize not reached.\n\n### Values\n- **Default 10ms** - Balances latency and throughput\n- **5ms** - Reduces latency but decreases batching efficiency\n- **20ms** - Increases batching efficiency but adds latency\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Shorter | Lower latency | Decreased batching efficiency |\n| Longer | Better batching | Higher latency |\n\nIn high-throughput scenarios, size typically reached before duration expires. In low-throughput scenarios, duration prevents indefinite waiting."`
	SpendBatcherSize                  int               `key:"utxostore_spendBatcherSize" desc:"Batch size for spend operations" default:"100" category:"UtxoStore" usage:"Number of spends per batch" type:"int" longdesc:"### Purpose\nControls the batch size for UTXO spend operations (marking outputs as spent).\n\n### How It Works\nBatcher accumulates spend requests and groups by parent transaction before executing up to SpendBatcherConcurrency concurrent Lua operations. Each Lua operation is atomic (all-or-nothing).\n\n### Values\n- **Default 100** - Balances memory usage and throughput\n- **200-500** - For high-transaction-rate scenarios\n\n### Use Cases\nDuring block validation, hundreds of transactions spent simultaneously benefit from batching.\n\n### Related Settings\nWorks with **SpendBatcherDurationMillis** and **SpendBatcherConcurrency** to optimize spend throughput."`
	SpendBatcherDurationMillis        int               `key:"utxostore_spendBatcherDurationMillis" desc:"Batching window for spend operations in milliseconds" default:"100" category:"UtxoStore" usage:"Time to accumulate spend operations" type:"int" longdesc:"### Purpose\nSets the batching window in milliseconds for spend operations.\n\n### How It Works\nBatcher fires after this duration or when SpendBatcherSize reached.\n\n### Values\n- **Default 100ms** - Optimized for block validation scenarios\n- **50ms** - For low-latency transaction propagation\n- **200ms** - During catchup to maximize batching efficiency\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Longer | More spends accumulate, reducing Aerospike load | Slower confirmation |\n| Shorter | Faster confirmation | Higher Aerospike load |\n\nBalance with **SpendBatcherSize** based on workload characteristics."`
	SpendBatcherConcurrency           int               `key:"utxostore_spendBatcherConcurrency" desc:"Concurrency for spend batcher" default:"32" category:"UtxoStore" usage:"Number of parallel spend operations" type:"int" longdesc:"### Purpose\nControls the number of parallel Lua spend operations executed concurrently.\n\n### How It Works\nAfter batcher accumulates requests, they are split across this many concurrent workers. Each concurrent operation executes atomic Lua script against Aerospike.\n\n### Values\n- **Default 32** - Optimized for typical Aerospike cluster configurations\n- **64-128** - For high-TPS scenarios (more throughput, more Aerospike load)\n- **16** - If Aerospike cluster shows signs of overload\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | Increased throughput | More memory usage and database load |\n| Lower | Reduced resource usage | Lower throughput |\n\nMonitor Aerospike performance when tuning."`
	SpendWaitTimeout                  time.Duration     `key:"utxostore_spendWaitTimeout" desc:"Timeout for spend wait operations" default:"30s" category:"UtxoStore" usage:"Maximum wait for spend confirmation" type:"duration" longdesc:"### Purpose\nSets the timeout duration waiting for UTXO spend confirmation.\n\n### How It Works\nIf spend operation does not complete within this duration, returns ErrTimeout. Timeouts trigger circuit breaker failure tracking (if enabled).\n\n### Values\n- **Default 30s** - Suitable for normal operations\n- **60s or higher** - For high network latency to Aerospike, overloaded Aerospike cluster, or catchup with massive transaction volumes\n\n### Important Distinction\nDifferent from **DBTimeout** (individual database operation) - this is end-to-end spend operation including batching and retries.\n\n### Troubleshooting\nPersistent timeouts may indicate infrastructure issues."`
	SpendCircuitBreakerFailureCount   int               `key:"utxostore_spendCircuitBreakerFailureCount" desc:"Failures before circuit breaker opens" default:"10" category:"UtxoStore" usage:"Threshold for spend operation failures" type:"int" longdesc:"### Purpose\nSets the number of consecutive infrastructure failures before opening circuit breaker for spend operations. Provides fail-fast protection against cascading failures when Aerospike is unhealthy.\n\n### Values\n- **Default 10** - Balances sensitivity and tolerance\n- **0** - Disables circuit breaker entirely\n- **5** - More aggressive circuit breaker\n- **20** - Increased tolerance for transient failures\n\n### What Gets Tracked\n**Only infrastructure failures:**\n- Connection errors\n- Batch operation failures\n- Database timeouts\n\n**NOT business logic errors:**\n- UTXO already spent\n- Frozen UTXO\n- Conflicting transaction\n\n### Circuit Breaker States\n- **CLOSED** - Normal operation\n- **OPEN** - Reject all requests\n- **HALF-OPEN** - Testing recovery\n\n### Related Settings\nWorks with **SpendCircuitBreakerCooldown** and **SpendCircuitBreakerHalfOpenMax**."`
	SpendCircuitBreakerCooldown       time.Duration     `key:"utxostore_spendCircuitBreakerCooldown" desc:"Cooldown before circuit breaker recovery" default:"30s" category:"UtxoStore" usage:"Wait time before testing recovery" type:"duration" longdesc:"### Purpose\nSets the cooldown duration before attempting recovery from OPEN circuit breaker state.\n\n### How It Works\nAfter consecutive failures reach SpendCircuitBreakerFailureCount, circuit opens and rejects all spend requests for this duration. After cooldown, circuit transitions to HALF-OPEN state allowing limited test requests.\n\n### Values\n- **Default 30s** - Gives Aerospike time to recover\n- **10s** - Faster recovery attempts (may cause repeated failures if issue not resolved)\n- **60s** - Longer recovery window (more conservative)\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Shorter | Faster recovery | May hammer unhealthy infrastructure |\n| Longer | Better recovery chance | Slower restoration of service |"`
	SpendCircuitBreakerHalfOpenMax    int               `key:"utxostore_spendCircuitBreakerHalfOpenMax" desc:"Max requests in half-open state" default:"4" category:"UtxoStore" usage:"Test requests before closing circuit" type:"int" longdesc:"### Purpose\nLimits the number of test requests allowed in HALF-OPEN circuit breaker state.\n\n### How It Works\nAfter cooldown expires, circuit allows up to this many requests to test system health. **ALL must succeed** to transition back to CLOSED state. If ANY fail, circuit returns to OPEN state.\n\n### Values\n- **Default 4** - Reasonable health check without overwhelming recovering system\n- **10** - More thorough health verification\n- **2** - Faster recovery (less conservative)\n\n### Important Note\nHALF-OPEN requests are actual spend operations, not synthetic health checks."`
	StoreBatcherDurationMillis        int               `key:"utxostore_storeBatcherDurationMillis" desc:"Batching window for store operations in milliseconds" default:"100" category:"UtxoStore" usage:"Time to accumulate store operations" type:"int" longdesc:"### Purpose\nSets the batching window in milliseconds for store operations.\n\n### How It Works\nBatcher fires after this duration even if StoreBatcherSize not reached. In block validation scenarios, size typically reached before duration expires due to burst of transactions.\n\n### Values\n- **Default 100ms** - Balances batching efficiency and confirmation latency\n- **50ms** - For real-time transaction propagation requiring faster confirmation\n- **200ms** - During catchup to maximize batch sizes and reduce Aerospike load"`
	StoreBatcherSize                  int               `key:"utxostore_storeBatcherSize" desc:"Batch size for store operations" default:"100" category:"UtxoStore" usage:"Number of operations per batch" type:"int" longdesc:"### Purpose\nControls the batch size for transaction storage operations (creating new UTXO records).\n\n### How It Works\nDuring block validation, hundreds of transactions created simultaneously. Batcher collects Create() operations and fires single BatchOperate call to Aerospike. Individual errors tracked per transaction within batch.\n\n### Values\n- **Default 100** - Suitable for typical block sizes\n- **500-1000** - For blocks containing 1000+ transactions (common during catchup)\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | Increased throughput, reduced Aerospike write load | More memory usage |\n| Lower | Lower memory usage | More database calls |\n\n### Related Settings\nWorks with **StoreBatcherDurationMillis**."`
	UtxoBatchSize                     int               `key:"utxostore_utxoBatchSize" desc:"Batch size for UTXO operations" default:"128" category:"UtxoStore" usage:"Number of UTXOs per batch" type:"int" longdesc:"### Purpose\nDefines the number of UTXOs per Aerospike record for transaction pagination.\n\n### How It Works\nTransactions with more outputs than this value are split across multiple records.\n\n**Example:** Transaction with 500 outputs creates 4 records:\n- main (0-127)\n- child1 (128-255)\n- child2 (256-383)\n- child3 (384-499)\n\n**Pagination formula:** offset = vout % UtxoBatchSize, recordIndex = vout / UtxoBatchSize\n\n### Values\n- **Default 128** - Cannot be changed after node initialization\n- **256** - Fewer records for large transactions, increased overhead for small transactions\n- **64** - Reduced overhead for small transactions\n\n### Warning\n**CRITICAL: NEVER change after initialization** - key calculations depend on this value. Requires full database rebuild."`
	IncrementBatcherSize              int               `key:"utxostore_incrementBatcherSize" desc:"Batch size for increment operations" default:"256" category:"UtxoStore" usage:"Number of increments per batch" type:"int" longdesc:"### Purpose\nControls the batch size for spent UTXO counter increment operations.\n\n### How It Works\nTransactions with >20,000 outputs use pagination records. When outputs spent, counter incremented on each pagination record. Batcher aggregates increment operations during high-throughput scenarios.\n\n### Values\n- **Default 256** - Suitable for typical workloads\n- **512-1024** - During catchup with large transactions\n\n### Related Settings\nWorks with **IncrementBatcherDurationMillis** to reduce Aerospike update load.\n\n### Note\nRarely needs adjustment unless processing many transactions with >20,000 outputs."`
	IncrementBatcherDurationMillis    int               `key:"utxostore_incrementBatcherDurationMillis" desc:"Batching window for increment operations in milliseconds" default:"10" category:"UtxoStore" usage:"Time to accumulate increments" type:"int" longdesc:"### Purpose\nSets the batching window in milliseconds for increment operations.\n\n### How It Works\nBatcher fires after this duration or when IncrementBatcherSize reached.\n\n### Values\n- **Default 10ms** - Quick batching without significant latency\n- **20ms** - During catchup to allow larger batches to form\n\n### Note\nRarely needs tuning as increment operations are infrequent for most transaction distributions."`
	SetDAHBatcherSize                 int               `key:"utxostore_setDAHBatcherSize" desc:"Batch size for SetDAH operations" default:"256" category:"UtxoStore" usage:"Number of DAH operations per batch" type:"int" longdesc:"### Purpose\nControls the batch size for Delete-At-Height (DAH) update operations.\n\n### How It Works\nWhen transaction fully spent, DAH set to currentHeight + BlockHeightRetention. Batcher aggregates DAH updates during spend operations.\n\n**DAH mechanism:**\n1. Transaction spent\n2. DAH set\n3. Pruner deletes when DAH <= currentHeight\n\n### Values\n- **Default 256** - Handles typical spend volumes\n- **512** - During catchup with massive spend volumes\n\n### Related Settings\nWorks with **SetDAHBatcherDurationMillis** to optimize DAH update throughput."`
	SetDAHBatcherDurationMillis       int               `key:"utxostore_setDAHBatcherDurationMillis" desc:"Batching window for SetDAH operations in milliseconds" default:"10" category:"UtxoStore" usage:"Time to accumulate DAH operations" type:"int" longdesc:"### Purpose\nSets the batching window in milliseconds for SetDAH operations.\n\n### How It Works\nBatcher fires after this duration or when SetDAHBatcherSize reached.\n\n### Values\n- **Default 10ms** - Quick DAH updates\n- **20ms** - During catchup to maximize batch efficiency\n\n### Note\nDAH updates are fire-and-forget optimizations - slightly higher latency acceptable for better batching."`
	LockedBatcherSize                 int               `key:"utxostore_lockedBatcherSize" desc:"Batch size for locked operations" default:"1024" category:"UtxoStore" usage:"Number of lock operations per batch" type:"int" longdesc:"### Purpose\nControls the batch size for locked status updates.\n\n### Use Cases\n- Coinbase maturity\n- Double-spend resolution\n- Alert system freezes\n\n### How It Works\nLocked updates often occur in bursts: block with 100 coinbase outputs locked for 100 blocks, conflicting transactions locked during double-spend handling.\n\n### Values\n- **Default 1024** - Handles burst scenarios efficiently\n- **2048** - For blocks with many coinbase transactions\n\n### Related Settings\nWorks with **LockedBatcherDurationMillis** to batch status updates."`
	LockedBatcherDurationMillis       int               `key:"utxostore_lockedBatcherDurationMillis" desc:"Batching window for locked operations in milliseconds" default:"5" category:"UtxoStore" usage:"Time to accumulate lock operations" type:"int" longdesc:"### Purpose\nSets the batching window in milliseconds for locked operations.\n\n### How It Works\nLocked updates typically occur in bursts during block validation. Quick batching window allows rapid processing of burst scenarios.\n\n### Values\n- **Default 5ms** - Short duration for burst processing\n\n### Behavior\n- In steady-state, locked updates are infrequent\n- During block validation, many coinbase outputs locked simultaneously benefit from batching"`
	LongestChainBatcherSize           int               `key:"utxostore_longestChainBatcherSize" desc:"Batch size for longest chain operations" default:"1024" category:"UtxoStore" usage:"Number of operations per batch" type:"int" longdesc:"### Purpose\nControls the batch size for longest chain marker updates during blockchain reorganizations.\n\n### How It Works\nWhen chain fork detected:\n- Transactions on orphaned chain marked onLongestChain=false\n- Transactions on winning chain marked onLongestChain=true\n\nReorgs are infrequent but affect many transactions simultaneously.\n\n### Values\n- **Default 1024** - Handles reorgs affecting hundreds to thousands of transactions\n- **2048-4096** - For deep reorgs (>100 blocks)\n\n### Related Settings\nWorks with **LongestChainBatcherDurationMillis** for efficient reorg processing."`
	LongestChainBatcherDurationMillis int               `key:"utxostore_longestChainBatcherDurationMillis" desc:"Batching window for longest chain operations in milliseconds" default:"5" category:"UtxoStore" usage:"Time to accumulate operations" type:"int" longdesc:"### Purpose\nSets the batching window in milliseconds for longest chain operations.\n\n### How It Works\nReorgs generate burst of updates that should be processed quickly. During reorg, many transactions updated simultaneously - size typically reached before duration expires.\n\n### Values\n- **Default 5ms** - Quick batching window ensures rapid completion of reorg marker updates"`
	GetBatcherSize                    int               `key:"utxostore_getBatcherSize" desc:"Batch size for get operations" default:"1" category:"UtxoStore" usage:"Number of get operations per batch" type:"int" longdesc:"### Purpose\nControls the batch size for transaction metadata Get() operations.\n\n### How It Works\n**Special case:** Default 1 effectively disables batching. Get() operations typically isolated (not concurrent) - batching adds latency without benefit.\n\n### Values\n- **Default 1** - Immediate execution without waiting\n- **100-500** - Only if application makes many concurrent Get() calls (e.g., Asset Server bulk transaction queries)\n\n### Behavior\nHigher values wait for multiple concurrent requests or GetBatcherDurationMillis timeout."`
	GetBatcherDurationMillis          int               `key:"utxostore_getBatcherDurationMillis" desc:"Batching window for get operations in milliseconds" default:"10" category:"UtxoStore" usage:"Time to accumulate get operations" type:"int" longdesc:"### Purpose\nSets the batching window in milliseconds for Get operations.\n\n### How It Works\nWorks with GetBatcherSize to accumulate concurrent Get() requests.\n\n### Values\n- **Default 10ms** - Quick batching if GetBatcherSize increased\n\n### Note\nWith default GetBatcherSize=1, this setting has minimal effect as requests execute immediately. Relevant only when GetBatcherSize >1 for applications with concurrent Get() patterns."`
	DBTimeout                         time.Duration     `key:"utxostore_dbTimeoutDuration" desc:"Database operation timeout" default:"5s" category:"UtxoStore" usage:"Increase for slow database connections" type:"duration" longdesc:"### Purpose\nSets the timeout duration for individual database operations (Get/Put/Delete/Batch/Query).\n\n### Scope\nApplies to Aerospike and PostgreSQL operations.\n\n### Values\n- **Default 5s** - Suitable for local/datacenter deployments\n- **10-30s** - For high network latency, during catchup with heavy load, overloaded database cluster, or slow queries with large result sets\n- **1-2s** - For ultra-low latency requirements (may cause spurious timeouts)\n\n### Important Distinction\nDifferent from **SpendWaitTimeout** (end-to-end spend operation) - this is per-operation timeout.\n\n### Note\nTimeout failures may trigger circuit breaker if frequent."`
	UseExternalTxCache                bool              `key:"utxostore_useExternalTxCache" desc:"Use external transaction cache" default:"true" category:"UtxoStore" usage:"Improves transaction lookup performance" type:"bool" longdesc:"### Purpose\nEnables a 10-second expiring concurrent cache for external transactions (>32KB stored in blob storage).\n\n### Why It Matters\nExternal transactions benefit greatly: large transaction with 100,000 outputs being spent simultaneously - first read fetches from blob storage (50-200ms), next 99,999 reads from cache (<1ms). Provides 100,000x reduction in blob storage calls.\n\n### Values\n- **Default true** - ALWAYS keep enabled in production\n- **false** - Only for testing/debugging external storage behavior\n\n### Details\n- Cache lifetime is 10 seconds (hardcoded)\n- Cache stored in memory - monitor memory usage for workloads with many large concurrent transactions"`
	ExternalizeAllTransactions        bool              `key:"utxostore_externalizeAllTransactions" desc:"Externalize all transactions to cache" default:"false" category:"UtxoStore" usage:"Store all transactions in external cache" type:"bool" longdesc:"### Purpose\nForces ALL transactions to be stored in blob storage regardless of size.\n\n### Normal Behavior\nOnly transactions >32KB externalized.\n\n### Values\n- **Default false** - Keep in production to minimize blob storage costs\n- **true** - Only for testing external storage behavior, validating blob storage integration, or debugging externalization logic\n\n### Production Impact\nIncreases blob storage costs and API calls without performance benefit for small transactions."`
	ExternalStoreConcurrency          int               `key:"utxostore_externalStoreConcurrency" desc:"Maximum concurrent external storage operations" default:"16" category:"UtxoStore" usage:"0 = unlimited, otherwise max concurrency" type:"int" longdesc:"### Purpose\nLimits concurrent blob storage (S3/filesystem) operations via semaphore.\n\n### How It Works\nPrevents overwhelming blob storage API rate limits by limiting concurrent operations.\n\n### Values\n- **Default 16** - Reasonable concurrency for S3 API limits\n- **0** - Unlimited concurrency (NOT RECOMMENDED - can exceed API rate limits)\n- **32-64** - For high-throughput catchup scenarios with many large external transactions\n\n### Important Distinction\nDifferent from circuit breaker (fail-fast protection) - this is concurrency control (always active).\n\n### Related Settings\nWorks with **UseExternalTxCache** to reduce blob storage load.\n\n### Note\nMonitor S3 API rate limits and costs when tuning."`
	PostgresPool                      *PostgresSettings `key:"utxostore_postgres_pool" desc:"PostgreSQL connection pool settings for UTXO store" default:"nil" category:"UtxoStore" usage:"Overrides global settings if specified" type:"*PostgresSettings" longdesc:"### Purpose\nOverrides global PostgreSQL connection pool settings specifically for UTXO store.\n\n### Included Settings\n- **MaxOpenConns** - Maximum open connections\n- **MaxIdleConns** - Maximum idle connections in pool\n- **ConnMaxLifetime** - Maximum connection lifetime\n- **ConnMaxIdleTime** - Maximum idle time before closing\n\n### Values\n- **Default nil** - Inherits from global PostgresSettings\n\n### When to Override\n- UTXO store requires more connections than other services\n- Different connection lifecycle requirements\n- Separate database instance for UTXO store\n\n### Recommendation\nMost deployments should use global settings for consistency."`
	VerboseDebug                      bool              `key:"utxostore_verbose_debug" desc:"Enable verbose debug logging" default:"false" category:"UtxoStore" usage:"Very detailed UTXO operation logging" type:"bool" longdesc:"### Purpose\nEnables extremely detailed logging for every UTXO operation.\n\n### What Gets Logged\n- Every Create/Get/Spend operation with parameters\n- Batch operation details\n- DAH updates\n- Mined status changes\n- Performance metrics\n\n### Values\n- **Default false** - ALWAYS keep disabled in production\n- **true** - Only for short debugging sessions\n\n### Warning\n**SEVERE performance impact:** Logs every operation creating huge log volume and significant overhead.\n\n### When to Enable\n- Short debugging sessions\n- Investigating specific UTXO store issues\n- Performance profiling with controlled load\n- Transaction lifecycle investigation\n\nDisable immediately after debugging to restore performance."`
	UpdateTxMinedStatus               bool              `key:"utxostore_updateTxMinedStatus" desc:"Update transaction mined status in store" default:"true" category:"UtxoStore" usage:"Required for transaction tracking" type:"bool" longdesc:"### Purpose\nTracks which transactions have been included in mined blocks vs remain unmined.\n\n### Fields Updated\n- BlockIDs\n- BlockHeights\n- UnminedSince\n- OnLongestChain\n\n### Critical For\n- Pruning logic (only prune mined transactions)\n- Mempool management (remove mined transactions)\n- Transaction status queries via Asset Server API\n\n### Values\n- **Default true** - ALWAYS keep enabled in production\n- **false** - Only for specialized testing scenarios\n\n### Behavior When Enabled\n- Block validated - update all transaction mined status\n- Reorg detected - clear BlockIDs for orphaned transactions\n\n### Warning\nWithout this, pruner cannot distinguish mined vs unmined transactions causing incorrect pruning behavior."`
	MaxMinedRoutines                  int               `key:"utxostore_maxMinedRoutines" desc:"Maximum concurrent routines for mined operations" default:"128" category:"UtxoStore" usage:"Parallel mined status updates" type:"int" longdesc:"### Purpose\nControls the number of concurrent goroutines updating mined status when a block is validated.\n\n### How It Works\nBlock with 10,000 transactions split across 128 parallel workers (approximately 78 transactions per worker).\n\n### Values\n- **Default 128** - Optimized for typical block sizes, provides faster block validation completion\n- **256** - For very large blocks during catchup\n- **32** - For low-CPU systems (slower block validation, less resource usage)\n\n### Trade-offs\n| Setting | Benefit | Drawback |\n|---------|---------|----------|\n| Higher | Faster block validation | More CPU usage and Aerospike writes |\n| Lower | Reduced resource usage | Slower block validation |\n\n### Related Settings\nWorks with **MaxMinedBatchSize** to optimize mined status update throughput."`
	MaxMinedBatchSize                 int               `key:"utxostore_maxMinedBatchSize" desc:"Maximum batch size for mined operations" default:"1024" category:"UtxoStore" usage:"Number of transactions per mined batch" type:"int" longdesc:"### Purpose\nControls the maximum number of transactions per mined status batch update operation.\n\n### How It Works\nBlock with 10,000 transactions split into batches of 1024 (10 batch operations to Aerospike). Each batch is single network round trip.\n\n### Values\n- **Default 1024** - Balanced for typical block sizes\n- **2048-4096** - For catchup mode processing old blocks (fewer network calls, higher throughput)\n- **512** - For real-time validation requiring lower latency per batch\n- **256-512** - If Aerospike shows signs of overload from large batches\n\n### Related Settings\nWorks with **MaxMinedRoutines** for parallel batch processing."`
	BlockHeightRetentionAdjustment    int32             `key:"utxostore_blockHeightRetentionAdjustment" desc:"Adjustment to global block height retention" default:"0" category:"UtxoStore" usage:"Can be positive or negative" type:"int32" longdesc:"### Purpose\nFine-tunes retention per service without changing global GlobalBlockHeightRetention setting.\n\n### How It Works\n- Positive values extend retention\n- Negative values reduce retention\n\n**Calculation:** effectiveRetention = GlobalBlockHeightRetention + BlockHeightRetentionAdjustment\n\n### Values\n- **Default 0** - Uses global value\n- **Common range** - -100 to +500\n\n### Example Scenarios\n- **Asset Server +200** - Longer history for API queries\n- **Validator 0** - Use global default\n- **Block Assembly -50** - Aggressive cleanup\n\n### Warning\nNegative adjustments below -100 **NOT RECOMMENDED** due to reorg safety concerns."`
	DisableDAHCleaner                 bool              `key:"utxostore_disableDAHCleaner" desc:"Disable the DAH cleaner process" default:"false" category:"UtxoStore" usage:"Use for debugging DAH issues" type:"bool" longdesc:"### Purpose\nDisables Phase 2 DAH (Delete-At-Height) pruning process.\n\n### Two-Phase Pruning\n- **Phase 1** - Preserves parent transactions of old unmined transactions (CRITICAL - must succeed)\n- **Phase 2** - Deletes records where DeleteAtHeight <= currentHeight (runs only if Phase 1 succeeds)\n\nWhen disabled, Phase 1 (parent preservation) still runs.\n\n### Values\n- **Default false** - Keep enabled in production for normal operation\n- **true** - Only for specific debugging scenarios\n\n### When to Disable\n- Temporarily debugging pruning issues (investigate why records pruned unexpectedly)\n- Data recovery scenarios (restore from backup without losing recent data)\n- Testing/development (keep full transaction history)\n\n### Warning\n**Disabling causes unbounded database growth.** Only disable temporarily for debugging. Re-enable after fixing root cause."`
}
