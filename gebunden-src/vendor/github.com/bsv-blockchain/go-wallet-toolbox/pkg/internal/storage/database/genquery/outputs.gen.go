// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package genquery

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/bsv-blockchain/go-wallet-toolbox/pkg/internal/storage/database/models"
)

func newOutput(db *gorm.DB, opts ...gen.DOOption) output {
	_output := output{}

	_output.outputDo.UseDB(db, opts...)
	_output.outputDo.UseModel(&models.Output{})

	tableName := _output.outputDo.TableName()
	_output.ALL = field.NewAsterisk(tableName)
	_output.ID = field.NewUint(tableName, "id")
	_output.CreatedAt = field.NewTime(tableName, "created_at")
	_output.UpdatedAt = field.NewTime(tableName, "updated_at")
	_output.DeletedAt = field.NewField(tableName, "deleted_at")
	_output.UserID = field.NewInt(tableName, "user_id")
	_output.TransactionID = field.NewUint(tableName, "transaction_id")
	_output.SpentBy = field.NewUint(tableName, "spent_by")
	_output.Vout = field.NewUint32(tableName, "vout")
	_output.Satoshis = field.NewInt64(tableName, "satoshis")
	_output.LockingScript = field.NewBytes(tableName, "locking_script")
	_output.CustomInstructions = field.NewString(tableName, "custom_instructions")
	_output.DerivationPrefix = field.NewString(tableName, "derivation_prefix")
	_output.DerivationSuffix = field.NewString(tableName, "derivation_suffix")
	_output.BasketName = field.NewString(tableName, "basket_name")
	_output.Spendable = field.NewBool(tableName, "spendable")
	_output.Change = field.NewBool(tableName, "change")
	_output.Description = field.NewString(tableName, "description")
	_output.ProvidedBy = field.NewString(tableName, "provided_by")
	_output.Purpose = field.NewString(tableName, "purpose")
	_output.Type = field.NewString(tableName, "type")
	_output.SenderIdentityKey = field.NewString(tableName, "sender_identity_key")
	_output.UserUTXO = outputHasOneUserUTXO{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("UserUTXO", "models.UserUTXO"),
		Output: struct {
			field.RelationField
			Basket struct {
				field.RelationField
			}
			Transaction struct {
				field.RelationField
				Commission struct {
					field.RelationField
				}
				Outputs struct {
					field.RelationField
				}
				Inputs struct {
					field.RelationField
				}
				ReservedUtxos struct {
					field.RelationField
				}
				Labels struct {
					field.RelationField
					Transactions struct {
						field.RelationField
					}
				}
			}
			SpentByTransaction struct {
				field.RelationField
			}
			UserUTXO struct {
				field.RelationField
			}
			Tags struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("UserUTXO.Output", "models.Output"),
			Basket: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("UserUTXO.Output.Basket", "models.OutputBasket"),
			},
			Transaction: struct {
				field.RelationField
				Commission struct {
					field.RelationField
				}
				Outputs struct {
					field.RelationField
				}
				Inputs struct {
					field.RelationField
				}
				ReservedUtxos struct {
					field.RelationField
				}
				Labels struct {
					field.RelationField
					Transactions struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("UserUTXO.Output.Transaction", "models.Transaction"),
				Commission: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("UserUTXO.Output.Transaction.Commission", "models.Commission"),
				},
				Outputs: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("UserUTXO.Output.Transaction.Outputs", "models.Output"),
				},
				Inputs: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("UserUTXO.Output.Transaction.Inputs", "models.Output"),
				},
				ReservedUtxos: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("UserUTXO.Output.Transaction.ReservedUtxos", "models.UserUTXO"),
				},
				Labels: struct {
					field.RelationField
					Transactions struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("UserUTXO.Output.Transaction.Labels", "models.Label"),
					Transactions: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("UserUTXO.Output.Transaction.Labels.Transactions", "models.Transaction"),
					},
				},
			},
			SpentByTransaction: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("UserUTXO.Output.SpentByTransaction", "models.Transaction"),
			},
			UserUTXO: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("UserUTXO.Output.UserUTXO", "models.UserUTXO"),
			},
			Tags: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("UserUTXO.Output.Tags", "models.Tag"),
			},
		},
		Basket: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("UserUTXO.Basket", "models.OutputBasket"),
		},
		ReservedBy: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("UserUTXO.ReservedBy", "models.Transaction"),
		},
	}

	_output.Basket = outputBelongsToBasket{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Basket", "models.OutputBasket"),
	}

	_output.Transaction = outputBelongsToTransaction{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Transaction", "models.Transaction"),
	}

	_output.SpentByTransaction = outputBelongsToSpentByTransaction{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("SpentByTransaction", "models.Transaction"),
	}

	_output.Tags = outputManyToManyTags{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Tags", "models.Tag"),
	}

	_output.fillFieldMap()

	return _output
}

type output struct {
	outputDo

	ALL                field.Asterisk
	ID                 field.Uint
	CreatedAt          field.Time
	UpdatedAt          field.Time
	DeletedAt          field.Field
	UserID             field.Int
	TransactionID      field.Uint
	SpentBy            field.Uint
	Vout               field.Uint32
	Satoshis           field.Int64
	LockingScript      field.Bytes
	CustomInstructions field.String
	DerivationPrefix   field.String
	DerivationSuffix   field.String
	BasketName         field.String
	Spendable          field.Bool
	Change             field.Bool
	Description        field.String
	ProvidedBy         field.String
	Purpose            field.String
	Type               field.String
	SenderIdentityKey  field.String
	UserUTXO           outputHasOneUserUTXO

	Basket outputBelongsToBasket

	Transaction outputBelongsToTransaction

	SpentByTransaction outputBelongsToSpentByTransaction

	Tags outputManyToManyTags

	fieldMap map[string]field.Expr
}

func (o output) Table(newTableName string) *output {
	o.outputDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o output) As(alias string) *output {
	o.outputDo.DO = *(o.outputDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *output) updateTableName(table string) *output {
	o.ALL = field.NewAsterisk(table)
	o.ID = field.NewUint(table, "id")
	o.CreatedAt = field.NewTime(table, "created_at")
	o.UpdatedAt = field.NewTime(table, "updated_at")
	o.DeletedAt = field.NewField(table, "deleted_at")
	o.UserID = field.NewInt(table, "user_id")
	o.TransactionID = field.NewUint(table, "transaction_id")
	o.SpentBy = field.NewUint(table, "spent_by")
	o.Vout = field.NewUint32(table, "vout")
	o.Satoshis = field.NewInt64(table, "satoshis")
	o.LockingScript = field.NewBytes(table, "locking_script")
	o.CustomInstructions = field.NewString(table, "custom_instructions")
	o.DerivationPrefix = field.NewString(table, "derivation_prefix")
	o.DerivationSuffix = field.NewString(table, "derivation_suffix")
	o.BasketName = field.NewString(table, "basket_name")
	o.Spendable = field.NewBool(table, "spendable")
	o.Change = field.NewBool(table, "change")
	o.Description = field.NewString(table, "description")
	o.ProvidedBy = field.NewString(table, "provided_by")
	o.Purpose = field.NewString(table, "purpose")
	o.Type = field.NewString(table, "type")
	o.SenderIdentityKey = field.NewString(table, "sender_identity_key")

	o.fillFieldMap()

	return o
}

func (o *output) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *output) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 26)
	o.fieldMap["id"] = o.ID
	o.fieldMap["created_at"] = o.CreatedAt
	o.fieldMap["updated_at"] = o.UpdatedAt
	o.fieldMap["deleted_at"] = o.DeletedAt
	o.fieldMap["user_id"] = o.UserID
	o.fieldMap["transaction_id"] = o.TransactionID
	o.fieldMap["spent_by"] = o.SpentBy
	o.fieldMap["vout"] = o.Vout
	o.fieldMap["satoshis"] = o.Satoshis
	o.fieldMap["locking_script"] = o.LockingScript
	o.fieldMap["custom_instructions"] = o.CustomInstructions
	o.fieldMap["derivation_prefix"] = o.DerivationPrefix
	o.fieldMap["derivation_suffix"] = o.DerivationSuffix
	o.fieldMap["basket_name"] = o.BasketName
	o.fieldMap["spendable"] = o.Spendable
	o.fieldMap["change"] = o.Change
	o.fieldMap["description"] = o.Description
	o.fieldMap["provided_by"] = o.ProvidedBy
	o.fieldMap["purpose"] = o.Purpose
	o.fieldMap["type"] = o.Type
	o.fieldMap["sender_identity_key"] = o.SenderIdentityKey

}

func (o output) clone(db *gorm.DB) output {
	o.outputDo.ReplaceConnPool(db.Statement.ConnPool)
	o.UserUTXO.db = db.Session(&gorm.Session{Initialized: true})
	o.UserUTXO.db.Statement.ConnPool = db.Statement.ConnPool
	o.Basket.db = db.Session(&gorm.Session{Initialized: true})
	o.Basket.db.Statement.ConnPool = db.Statement.ConnPool
	o.Transaction.db = db.Session(&gorm.Session{Initialized: true})
	o.Transaction.db.Statement.ConnPool = db.Statement.ConnPool
	o.SpentByTransaction.db = db.Session(&gorm.Session{Initialized: true})
	o.SpentByTransaction.db.Statement.ConnPool = db.Statement.ConnPool
	o.Tags.db = db.Session(&gorm.Session{Initialized: true})
	o.Tags.db.Statement.ConnPool = db.Statement.ConnPool
	return o
}

func (o output) replaceDB(db *gorm.DB) output {
	o.outputDo.ReplaceDB(db)
	o.UserUTXO.db = db.Session(&gorm.Session{})
	o.Basket.db = db.Session(&gorm.Session{})
	o.Transaction.db = db.Session(&gorm.Session{})
	o.SpentByTransaction.db = db.Session(&gorm.Session{})
	o.Tags.db = db.Session(&gorm.Session{})
	return o
}

type outputHasOneUserUTXO struct {
	db *gorm.DB

	field.RelationField

	Output struct {
		field.RelationField
		Basket struct {
			field.RelationField
		}
		Transaction struct {
			field.RelationField
			Commission struct {
				field.RelationField
			}
			Outputs struct {
				field.RelationField
			}
			Inputs struct {
				field.RelationField
			}
			ReservedUtxos struct {
				field.RelationField
			}
			Labels struct {
				field.RelationField
				Transactions struct {
					field.RelationField
				}
			}
		}
		SpentByTransaction struct {
			field.RelationField
		}
		UserUTXO struct {
			field.RelationField
		}
		Tags struct {
			field.RelationField
		}
	}
	Basket struct {
		field.RelationField
	}
	ReservedBy struct {
		field.RelationField
	}
}

func (a outputHasOneUserUTXO) Where(conds ...field.Expr) *outputHasOneUserUTXO {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a outputHasOneUserUTXO) WithContext(ctx context.Context) *outputHasOneUserUTXO {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a outputHasOneUserUTXO) Session(session *gorm.Session) *outputHasOneUserUTXO {
	a.db = a.db.Session(session)
	return &a
}

func (a outputHasOneUserUTXO) Model(m *models.Output) *outputHasOneUserUTXOTx {
	return &outputHasOneUserUTXOTx{a.db.Model(m).Association(a.Name())}
}

func (a outputHasOneUserUTXO) Unscoped() *outputHasOneUserUTXO {
	a.db = a.db.Unscoped()
	return &a
}

type outputHasOneUserUTXOTx struct{ tx *gorm.Association }

func (a outputHasOneUserUTXOTx) Find() (result *models.UserUTXO, err error) {
	return result, a.tx.Find(&result)
}

func (a outputHasOneUserUTXOTx) Append(values ...*models.UserUTXO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a outputHasOneUserUTXOTx) Replace(values ...*models.UserUTXO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a outputHasOneUserUTXOTx) Delete(values ...*models.UserUTXO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a outputHasOneUserUTXOTx) Clear() error {
	return a.tx.Clear()
}

func (a outputHasOneUserUTXOTx) Count() int64 {
	return a.tx.Count()
}

func (a outputHasOneUserUTXOTx) Unscoped() *outputHasOneUserUTXOTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type outputBelongsToBasket struct {
	db *gorm.DB

	field.RelationField
}

func (a outputBelongsToBasket) Where(conds ...field.Expr) *outputBelongsToBasket {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a outputBelongsToBasket) WithContext(ctx context.Context) *outputBelongsToBasket {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a outputBelongsToBasket) Session(session *gorm.Session) *outputBelongsToBasket {
	a.db = a.db.Session(session)
	return &a
}

func (a outputBelongsToBasket) Model(m *models.Output) *outputBelongsToBasketTx {
	return &outputBelongsToBasketTx{a.db.Model(m).Association(a.Name())}
}

func (a outputBelongsToBasket) Unscoped() *outputBelongsToBasket {
	a.db = a.db.Unscoped()
	return &a
}

type outputBelongsToBasketTx struct{ tx *gorm.Association }

func (a outputBelongsToBasketTx) Find() (result *models.OutputBasket, err error) {
	return result, a.tx.Find(&result)
}

func (a outputBelongsToBasketTx) Append(values ...*models.OutputBasket) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a outputBelongsToBasketTx) Replace(values ...*models.OutputBasket) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a outputBelongsToBasketTx) Delete(values ...*models.OutputBasket) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a outputBelongsToBasketTx) Clear() error {
	return a.tx.Clear()
}

func (a outputBelongsToBasketTx) Count() int64 {
	return a.tx.Count()
}

func (a outputBelongsToBasketTx) Unscoped() *outputBelongsToBasketTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type outputBelongsToTransaction struct {
	db *gorm.DB

	field.RelationField
}

func (a outputBelongsToTransaction) Where(conds ...field.Expr) *outputBelongsToTransaction {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a outputBelongsToTransaction) WithContext(ctx context.Context) *outputBelongsToTransaction {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a outputBelongsToTransaction) Session(session *gorm.Session) *outputBelongsToTransaction {
	a.db = a.db.Session(session)
	return &a
}

func (a outputBelongsToTransaction) Model(m *models.Output) *outputBelongsToTransactionTx {
	return &outputBelongsToTransactionTx{a.db.Model(m).Association(a.Name())}
}

func (a outputBelongsToTransaction) Unscoped() *outputBelongsToTransaction {
	a.db = a.db.Unscoped()
	return &a
}

type outputBelongsToTransactionTx struct{ tx *gorm.Association }

func (a outputBelongsToTransactionTx) Find() (result *models.Transaction, err error) {
	return result, a.tx.Find(&result)
}

func (a outputBelongsToTransactionTx) Append(values ...*models.Transaction) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a outputBelongsToTransactionTx) Replace(values ...*models.Transaction) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a outputBelongsToTransactionTx) Delete(values ...*models.Transaction) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a outputBelongsToTransactionTx) Clear() error {
	return a.tx.Clear()
}

func (a outputBelongsToTransactionTx) Count() int64 {
	return a.tx.Count()
}

func (a outputBelongsToTransactionTx) Unscoped() *outputBelongsToTransactionTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type outputBelongsToSpentByTransaction struct {
	db *gorm.DB

	field.RelationField
}

func (a outputBelongsToSpentByTransaction) Where(conds ...field.Expr) *outputBelongsToSpentByTransaction {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a outputBelongsToSpentByTransaction) WithContext(ctx context.Context) *outputBelongsToSpentByTransaction {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a outputBelongsToSpentByTransaction) Session(session *gorm.Session) *outputBelongsToSpentByTransaction {
	a.db = a.db.Session(session)
	return &a
}

func (a outputBelongsToSpentByTransaction) Model(m *models.Output) *outputBelongsToSpentByTransactionTx {
	return &outputBelongsToSpentByTransactionTx{a.db.Model(m).Association(a.Name())}
}

func (a outputBelongsToSpentByTransaction) Unscoped() *outputBelongsToSpentByTransaction {
	a.db = a.db.Unscoped()
	return &a
}

type outputBelongsToSpentByTransactionTx struct{ tx *gorm.Association }

func (a outputBelongsToSpentByTransactionTx) Find() (result *models.Transaction, err error) {
	return result, a.tx.Find(&result)
}

func (a outputBelongsToSpentByTransactionTx) Append(values ...*models.Transaction) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a outputBelongsToSpentByTransactionTx) Replace(values ...*models.Transaction) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a outputBelongsToSpentByTransactionTx) Delete(values ...*models.Transaction) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a outputBelongsToSpentByTransactionTx) Clear() error {
	return a.tx.Clear()
}

func (a outputBelongsToSpentByTransactionTx) Count() int64 {
	return a.tx.Count()
}

func (a outputBelongsToSpentByTransactionTx) Unscoped() *outputBelongsToSpentByTransactionTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type outputManyToManyTags struct {
	db *gorm.DB

	field.RelationField
}

func (a outputManyToManyTags) Where(conds ...field.Expr) *outputManyToManyTags {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a outputManyToManyTags) WithContext(ctx context.Context) *outputManyToManyTags {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a outputManyToManyTags) Session(session *gorm.Session) *outputManyToManyTags {
	a.db = a.db.Session(session)
	return &a
}

func (a outputManyToManyTags) Model(m *models.Output) *outputManyToManyTagsTx {
	return &outputManyToManyTagsTx{a.db.Model(m).Association(a.Name())}
}

func (a outputManyToManyTags) Unscoped() *outputManyToManyTags {
	a.db = a.db.Unscoped()
	return &a
}

type outputManyToManyTagsTx struct{ tx *gorm.Association }

func (a outputManyToManyTagsTx) Find() (result []*models.Tag, err error) {
	return result, a.tx.Find(&result)
}

func (a outputManyToManyTagsTx) Append(values ...*models.Tag) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a outputManyToManyTagsTx) Replace(values ...*models.Tag) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a outputManyToManyTagsTx) Delete(values ...*models.Tag) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a outputManyToManyTagsTx) Clear() error {
	return a.tx.Clear()
}

func (a outputManyToManyTagsTx) Count() int64 {
	return a.tx.Count()
}

func (a outputManyToManyTagsTx) Unscoped() *outputManyToManyTagsTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type outputDo struct{ gen.DO }

type IOutputDo interface {
	gen.SubQuery
	Debug() IOutputDo
	WithContext(ctx context.Context) IOutputDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IOutputDo
	WriteDB() IOutputDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IOutputDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IOutputDo
	Not(conds ...gen.Condition) IOutputDo
	Or(conds ...gen.Condition) IOutputDo
	Select(conds ...field.Expr) IOutputDo
	Where(conds ...gen.Condition) IOutputDo
	Order(conds ...field.Expr) IOutputDo
	Distinct(cols ...field.Expr) IOutputDo
	Omit(cols ...field.Expr) IOutputDo
	Join(table schema.Tabler, on ...field.Expr) IOutputDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IOutputDo
	RightJoin(table schema.Tabler, on ...field.Expr) IOutputDo
	Group(cols ...field.Expr) IOutputDo
	Having(conds ...gen.Condition) IOutputDo
	Limit(limit int) IOutputDo
	Offset(offset int) IOutputDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IOutputDo
	Unscoped() IOutputDo
	Create(values ...*models.Output) error
	CreateInBatches(values []*models.Output, batchSize int) error
	Save(values ...*models.Output) error
	First() (*models.Output, error)
	Take() (*models.Output, error)
	Last() (*models.Output, error)
	Find() ([]*models.Output, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.Output, err error)
	FindInBatches(result *[]*models.Output, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.Output) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IOutputDo
	Assign(attrs ...field.AssignExpr) IOutputDo
	Joins(fields ...field.RelationField) IOutputDo
	Preload(fields ...field.RelationField) IOutputDo
	FirstOrInit() (*models.Output, error)
	FirstOrCreate() (*models.Output, error)
	FindByPage(offset int, limit int) (result []*models.Output, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IOutputDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (o outputDo) Debug() IOutputDo {
	return o.withDO(o.DO.Debug())
}

func (o outputDo) WithContext(ctx context.Context) IOutputDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o outputDo) ReadDB() IOutputDo {
	return o.Clauses(dbresolver.Read)
}

func (o outputDo) WriteDB() IOutputDo {
	return o.Clauses(dbresolver.Write)
}

func (o outputDo) Session(config *gorm.Session) IOutputDo {
	return o.withDO(o.DO.Session(config))
}

func (o outputDo) Clauses(conds ...clause.Expression) IOutputDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o outputDo) Returning(value interface{}, columns ...string) IOutputDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o outputDo) Not(conds ...gen.Condition) IOutputDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o outputDo) Or(conds ...gen.Condition) IOutputDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o outputDo) Select(conds ...field.Expr) IOutputDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o outputDo) Where(conds ...gen.Condition) IOutputDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o outputDo) Order(conds ...field.Expr) IOutputDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o outputDo) Distinct(cols ...field.Expr) IOutputDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o outputDo) Omit(cols ...field.Expr) IOutputDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o outputDo) Join(table schema.Tabler, on ...field.Expr) IOutputDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o outputDo) LeftJoin(table schema.Tabler, on ...field.Expr) IOutputDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o outputDo) RightJoin(table schema.Tabler, on ...field.Expr) IOutputDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o outputDo) Group(cols ...field.Expr) IOutputDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o outputDo) Having(conds ...gen.Condition) IOutputDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o outputDo) Limit(limit int) IOutputDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o outputDo) Offset(offset int) IOutputDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o outputDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IOutputDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o outputDo) Unscoped() IOutputDo {
	return o.withDO(o.DO.Unscoped())
}

func (o outputDo) Create(values ...*models.Output) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o outputDo) CreateInBatches(values []*models.Output, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o outputDo) Save(values ...*models.Output) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o outputDo) First() (*models.Output, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.Output), nil
	}
}

func (o outputDo) Take() (*models.Output, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.Output), nil
	}
}

func (o outputDo) Last() (*models.Output, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.Output), nil
	}
}

func (o outputDo) Find() ([]*models.Output, error) {
	result, err := o.DO.Find()
	return result.([]*models.Output), err
}

func (o outputDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.Output, err error) {
	buf := make([]*models.Output, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o outputDo) FindInBatches(result *[]*models.Output, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o outputDo) Attrs(attrs ...field.AssignExpr) IOutputDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o outputDo) Assign(attrs ...field.AssignExpr) IOutputDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o outputDo) Joins(fields ...field.RelationField) IOutputDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o outputDo) Preload(fields ...field.RelationField) IOutputDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o outputDo) FirstOrInit() (*models.Output, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.Output), nil
	}
}

func (o outputDo) FirstOrCreate() (*models.Output, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.Output), nil
	}
}

func (o outputDo) FindByPage(offset int, limit int) (result []*models.Output, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o outputDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o outputDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o outputDo) Delete(models ...*models.Output) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *outputDo) withDO(do gen.Dao) *outputDo {
	o.DO = *do.(*gen.DO)
	return o
}
